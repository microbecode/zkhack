{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":13006106641385494867,"abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":256},"visibility":"public"},{"name":"tx_hash","type":{"kind":"string","length":64},"visibility":"public"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"blob_contract_name","type":{"kind":"string","length":256},"visibility":"public"},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"success","type":{"kind":"boolean"},"visibility":"public"},{"name":"password","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"1837938722211649573":{"error_kind":"string","string":"extend_from_slice out of bounds"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7b3vjiRZct35LvN5Prj9N9OrLBYCRXGFAQakQFILLAS9+3pLU1nNyaz0uTFxTx2vSAggujXpfc094rpbHP+dY//zD//1n/7L//hv//lP//z//Mu//eE//V//8w9//pd//Id//9O//PP5b//zD+n5v/8//+2//8M///bv//bv//Cv//6H/yTh88c//NM//9fzH1Psf/3xD//Pn/78T3/4Tyn/648f/LFIf/vrEJPvf/6//u8/nkvU/iV6/xKzfYk4nrCEpb0tYfVuCdm/hO5fwvYv4c9YYvxtCT/0r5eI/Uvk/iVq/xK9f4nZvkQe+5eQ/Uvo/iVs/xL7d3fu3925f3fn/t2d+3d37t/dtX931/7dXft3d+3f3bV/d9f+3V37d3ft3921f3fX/t3d+3d379/dvX939/7d3ft3d+/f3b1/d/f+3d37d3fv392zf3fP/t09+3f37N/ds393z/7dPft39+zf3bN/d8/23V3HsX8J2b+E7l/C9i/h+5eI/Uvk/iVq/xK9f4n9u1v2727Zv7tl/+6W/btb9u9u2b+7Zf/ulv27W/bvbtm/u3X/7tb9u1v3727dv7t1/+7W/btb9+9u3b+7df/u1v272/bvbtu/u23/7rb9u9v2727bv7tt/+62/bvb9u9u27+7ff/u9v272/fvbt+/u33/7vb9u9v3727fv7t9/+72/bs79u/u2L+7Y//ujv27ez+rVvtZtdrPqtV+Vq32s2q1n1Wr/axa7WfVaj+rVvtZtdrPqtV+Vq32s2q1n1Wr/axa7WfVaj+rVvtZtdrPqtV+Vq32s2q1n1Wr/axa7WfVaj+rVvtZtdrPqtV+Vq32s2q1n1Wr/axa7WfVaj+rVvtZtdrPqtV+Vq32s2q1n1Wr/axa7WfVaj+rVvtZtdrPqtV+Vq32s2q1n1Xr/axa72fVej+r1vtZtT58/xKxf4ncv0TtX6L3L7F/d+9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/qzb7WbXZz6rNflZt9rNqc/j+JWL/Erl/idq/RO9fYv/u3s+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WTY79sNq5hgDWUMAaBljDAWsEYI0ErFGANRqwBmCfC2CfC2CfC2CfC2CfC2CfC2CfC2CfC2CfC2CfC2CfK2CfK2CfK2CfK2CfK2CfK2CfK2CfK2CfK2CfK2CfG2CfG2CfG2CfG2CfG2CfG2CfG2CfG2CfG2CfG2CfO2CfO2CfO2CfO2CfO2CfO2CfO2CfO2CfO2CfO2CfB2CfB2CfB2CfB2CfB2CfB2CfB2CfB2CfB2CfB2CfJ2CfJ2CfJ2CfJ2CfJ2CfJ2CfJ2CfJ2CfJ2CfJ2CfF2CfF2CfF2CfF2CfF2CfF2CfF2CfF2CfF2CfF2CfN2CfN2CfN2CfN2CfN2CfN2CfN2CfN2CfN2CfN2CfD2CfD2CfD2CfD2CfD2CfD2CfD2CfD2CfD2CfA3g4AfBwAuDhBMDDCYCHO8VXwBoBWCMBaxRgjQasAdjnAB5OADycAHg4AfBwAuDhBMDDCYCHEwAPJwAeTgA8nAB4OAHwcALg4QTAwwmAhxMADycAHk4APJwAeDgB8HAC4OEEwMMJgIcTAA8nAB5OADycAHg4AfBwAuDhBMDDCYCHEwAPJwAeTgA8nAB4OAHwcALg4QTAwwmAhxMADycAHk4APJwAeDgB8HAC4OEEwMMJgIcTAA8nAB5OADycAHg4AfBwAuDhBMDDCYCHEwAPJwAeTgA8nAB4OAHwcALg4QTAwwmAhxMADyfP4eHS3tawkndrBGCNBKxRgDUA+xzAwwmAhxMADycAHk4APJwAeDgB8HAC4OEEwMMJgIcTAA8nAB5OADycAHg4AfBwAuDhBMDDCYCHEwAPJwAeTgA8nAJ4OAXwcArg4RTAw+nhgDUCsEYC1ijAGg1YA7DPATycAng4BfBwCuDhFMDDKYCHUwAPpwAeTgE8nAJ4OAXwcArg4RTAwymAh1MAD6cAHk4BPJwCeDgF8HAK4OEUwMMpgIdTAA+nAB5OATycAng4BfBwCuDhFMDDKYCHUwAPpwAeTgE8nAJ4OAXwcArg4RTAwymAh1MAD6cAHk4BPJwCeDgF8HAK4OEUwMMpgIdTAA+nAB5OATycAng4BfBwCuDhFMDDKYCHUwAPpwAeTgE8nAJ4OAXwcArg4RTAwymAh1MAD6cAHk4B+XAKyIdTQD6cAvLhFMDDKYCHUwAPpwAeTgE8nAJ4OAXwcArg4RTAwymAh1MAD6cAHk4BPJwCeDgF8HAK4OEUwMMpgIdTAA+nAB5OATycAng4A/BwBuDhDMDDGYCHs8MBawRgjQSsUYA1GrAGYJ8DeDgD8HAG4OEMwMMZgIczAA9nAB7OADycAXg4A/BwBuDhDMDDGYCHMwAPZwAezgA8nAF4OAPwcAbg4QzAwxmAhzMAD2cAHs4APJwBeDgD8HAG4OEMwMMZgIczAA9nAB7OADycAXg4A/BwBuDhDMDDGYCHMwAPZwAezgA8nAF4OAPwcAbg4QzAwxmAhzMAD2cAHs4APJwBeDgD8HAG4OEMwMMZgIczAA9nAB7OADycAXg4A/BwBuDhDMDDGYCHMwAPZwAezgA8nAF4OAPwcAbg4QzAwxmAhzMAD2cAHs4APJwBeDgD8HAG4OEMwMMZgIczAA9nAB7OADycAXg4A/BwBuDhDMDDGYCHMwAPZwAezgA8nAF4OAPwcA7g4RzAwzmAh3MAD+eHA9YIwBoJWKMAazRgDcA+B/BwDuDhHMDDOYCHcwAP5wAezgE8nAN4OAfwcA7g4RzAwzmAh3MAD+cAHs4BPJwDeDgH8HAO4OEcwMM5gIdzAA/nAB7OATycA3g4B/BwDuDhHMDDOYCHcwAP5wAezgE8nAN4OAfwcA7g4RzAwzmAh3MAD+cAHs4BPJwDeDgH8HAO4OEcwMM5gIdzAA/nAB7OATycA3g4B/BwDuDhHMDDOYCHcwAP5wAezgE8nAN4OAfwcA7g4RzAwzmAh3MAD+cAHs4BPJwDeDgH8HAO4OEcwMM5gIdzAA/nAB7OATycA3g4B/BwDuDhHMDDOYCHcwAP5wAezgE8nAN4OAfwcA7g4RzAwzmAh3MAD+cAHs4BPJwDeDgH8HAO4OECwMMFgIcLAA8XAB4uDgesEYA1ErBGAdZowBqAfQ7g4QLAwwWAhwsADxcAHi4APFwAeLgA8HAB4OECwMMFgIcLAA8XAB4uADxcAHi4APBwAeDhAsDDBYCHCwAPFwAeLgA8XAB4uADwcAHg4QLAwwWAhwsADxcAHi4APFwAeLgA8HAB4OECwMMFgIcLAA8XAB4uADxcAHi4APBwAeDhAsDDBYCHCwAPFwAeLgA8XAB4uADwcAHg4QLAwwWAhwsADxcAHi4APFwAeLgA8HAB4OECwMMFgIcLAA8XAB4uADxcAHi4APBwAeDhAsDDBYCHCwAPFwAeLgA8XAB4uADwcAHg4QLAwwWAhwsADxcAHi4APFwAeLgA8HAB4OECwMMFgIcLAA8XAB4uADxcAHi4APBwAeDhAsDDJYCHSwAPlwAeLgE8XB4OWCMAayRgjQKs0YA1APscwMMlgIdLAA+XAB4uATxcAni4BPBwCeDhEsDDJYCHSwAPlwAeLgE8XAJ4uATwcAng4RLAwyWAh0sAD5cAHi4BPFwCeLgE8HAJ4OESwMMlgIdLAA+XAB4uATxcAni4BPBwCeDhEsDDJYCHSwAPlwAeLgE8XAJ4uATwcAng4RLAwyWAh0sAD5cAHi4BPFwCeLgE8HAJ4OESwMMlgIdLAA+XAB4uATxcAni4BPBwCeDhEsDDJYCHSwAPlwAeLgE8XAJ4uATwcAng4RLAwyWAh0sAD5cAHi4BPFwCeLgE8HAJ4OESwMMlgIdLAA+XAB4uATxcAni4BPBwCeDhEsDDJYCHSwAPlwAeLgE8XAJ4uATwcAng4RLAwyWAhysAD1cAHq4APFwBeLg6HLBGANZIwBoFWKMBawD2OYCHKwAPVwAergA8XAF4uALwcAXg4QrAwxWAhysAD1cAHq4APFwBeLgC8HAF4OEKwMMVgIcrAA9XAB6uADxcAXi4AvBwBeDhCsDDFYCHKwAPVwAergA8XAF4uALwcAXg4QrAwxWAhysAD1cAHq4APFwBeLgC8HAF4OEKwMMVgIcrAA9XAB6uADxcAXi4AvBwBeDhCsDDFYCHKwAPVwAergA8XAF4uALwcAXg4QrAwxWAhysAD1cAHq4APFwBeLgC8HAF4OEKwMMVgIcrAA9XAB6uADxcAXi4AvBwBeDhCsDDFYCHKwAPVwAergA8XAF4uALwcAXg4QrAwxWAhysAD1cAHq4APFwBeLgC8HAF4OEKwMMVgIcrAA/XAB6uATxcA3i4BvBwfThgjQCskYA1CrBGA9YA7HMAD9cAHq4BPFwDeLgG8HAN4OEawMM1gIdrAA/XAB6uATxcA3i4BvBwDeDhGsDDNYCHawAP1wAergE8XAN4uAbwcA3g4RrAwzWAh2sAD9cAHq4BPFwDeLgG8HAN4OEawMM1gIdrAA/XAB6uATxcA3i4BvBwDeDhGsDDNYCHawAP1wAergE8XAN4uAbwcA3g4RrAwzWAh2sAD9cAHq4BPFwDeLgG8HAN4OEawMM1gIdrAA/XAB6uATxcA3i4BvBwDeDhGsDDNYCHawAP1wAergE8XAN4uAbwcA3g4RrAwzWAh2sAD9cAHq4BPFwDeLgG8HAN4OEawMM1gIdrAA/XAB6uATxcA3i4BvBwDeDhGsDDNYCHawAP1wAebgA83AB4uAHwcAPg4eZwwBoBWCMBaxRgjQasAdjnAB5uADzcAHi4AfBwA+DhBsDDDYCHGwAPNwAebgA83AB4uAHwcAPg4QbAww2AhxsADzcAHm4APNwAeLgB8HAD4OEGwMMNgIcbAA83AB5uADzcAHi4AfBwA+DhBsDDDYCHGwAPNwAebgA83AB4uAHwcAPg4eY5PFza2xpW8m6NBqwx+9d4Dg93sQZgnwN4uHkOD3dxrRywRgDWSMAagOc5gIebAOzzBOzz5/BwF2soYA3A8xzAw00C9nkC9nkCnucJeJ4DeLgB8HBTgH1egH1egOf5c3i4izUAfTuAh5sC7PMC7PMCPM8b8DwH8HAD4OGmAfu8Afu8Ac/zBjzPATzcAHi4acA+H8A+H8DzfADPcwAPNwAebgawzwewzwfwPB/A83w/D6fHfh7uXGP7Pj/XUMAaBljDAWsE4DNPwBoFuFYNWGP2ryEHYA3Z/5nv5+HONQD7XAD7XAKwRgLWKMBn3oA1APtcAftcAc9zBTzP9/Nw5xoOWAOwzxWwzxXwPFfA81wBfbsB+nYD7HMD7HMDPM+fw8NdrAHo2w3Qtxtgnxtgnxvgee6A57kD+nYH9O0O2OcO2OcOeJ474HnugL7dAX27A/Z5APZ5AJ7nAXieB6Bv358Pd64B2OcB2OcBeJ4H4HkegL49AX17AvZ5AvZ5Ap7nz+HhLtYA9O0J6NsTsM8TsM8T8DwvwPO8AH17Afr2AuzzAuzzAjzPC/A8L0DfXoC+vQD7vAH7vAHP8wY8zxvQt+/PhzvXAOzzBuzzBjzPG/A8b0DfPoC+fQD7fAD7fADP8+fwcBdrAPr2AfTtA9jnA9jns/95LscBWGN/3y778+HONQxwrRywRgDWSMAaBfjMG7AGYJ8DeDgRAayhgDX29+2yPx/uXAOwzwE8nEgB1mjAGvv7dtmfD3euAdjnAB5OFPA8fw4Pd7FGAD7zBKwB2OcAHk4U8Dw3wPPcAH27Afp2AA8nAB5ODPA8N8Dz3AB9uwH6dgAPJwAeThzwPHfA89wBffv+fLhzDcA+B/Bw4oDnuQOe5w7o2wPQtwN4OAHwcBKA5/n+fLhzDUDfHoC+HcDDCYCHkwA8zxPwPE9A356Avh3AwwmAh5MEPM8T8DxPQN+egL4dwMMJgIeTAjzPC/A8L0Dfvn9e6rkGYJ8DeDgpwPO8AM/zAvTtDejbATycAHg4acDzfH8+3LkGoG9vQN8O4OEEwMNJA57nA3ieD6BvH0DfDuDhBMDDyQCe5wN4ng+gbx9A3w7g4RTAwykgH04B+XC6f17quYYD1gjAtUrAGgVYowFr7O/bdf+81HMNwD4H8HAKyIdTQD6c7p+Xeq6RgDUA+xzAwykgH04B+XC6f17quYYC1gDscwAPp4B8OAXkw+n+eannGg1YA7DPATycAvLhFJAPpwbo2/fPSz3XAOxzAA+ngHw4BeTDqQH6dgf07QAeTgE8nALy4RSQD6cO6Nsd0LcDeDgF8HAKyIdTQD6cBqBvD0DfDuDhFMDDKSAfTgH5cBqAvj0AfTuAh1MAD6eAfDgF5MNpAvr2/fNSzzUA+xzAwykgH04B+XCagL69AH07gIdTAA+ngHw4BeTDaQH69gL07QAeTgE8nALy4RSQD6cN6Nsb0LcDeDgF8HAKyIdTQD6cNqBvb0DfDuDhFMDDKSAfTgH5cDqAvn3/vNRzDcA+B/BwCsiHU0A+nALmpRpgXqoBeDgD8HAGyIezwwFrBOAzT8AaBbhWDVhj//PcAPlwBpiXaoB5qQbg4QzAwxkgH84A+XAGmJdqgHmpBuDhDMDDGSAfzgD5cAaYl2qAeakG4OEMwMMZIB/OAPlwBpiXaoB5qQbg4QzAwxkgH84A+XAGmJdqgHmpBuDhDMDDGSAfzgD5cAaYl2qAeakG4OEMwMMZIB/OAPlwBpiXaoB5qQbg4QzAwxkgH84A+XAGmJdqgHmpBuDhDMDDGSAfzgD5cAaYl2qAeakG4OEMwMMZIB/OAPlwBpiXaoB5qQbg4QzAwxkgH84A+XAGmJdqgHmpBuDhDMDDGSAfzgD5cAaYl2qAeakG4OEMwMMZIB/OAPlwBpiXaoB5qQbg4QzAwxkgH84A+XAGmJdqgHmpBuDhDMDDGSAfzgD5cAaYl2qAeakG4OEMwMMZIB/OAflwDpiX6oB5qQ7g4fxwwBoBWCMBaxTgM2/AGoB9DuDhHJAP54B8OAfMS3XAvFQH8HAO4OEckA/ngHw4B8xLdcC8VAfwcA7g4RyQD+eAfDgHzEt1wLxUB/BwDuDhHJAP54B8OAfMS3XAvFQH8HAO4OEckA/ngHw4B8xLdcC8VAfwcA7g4RyQD+eAfDgHzEt1wLxUB/BwDuDhHJAP54B8OAfMS3XAvFQH8HAO4OEckA/ngHw4B8xLdcC8VAfwcA7g4RyQD+eAfDgHzEt1wLxUB/BwDuDhHJAP54B8OAfMS3XAvFQH8HAO4OEckA/ngHw4B8xLdcC8VAfwcA7g4RyQD+eAfDgHzEt1wLxUB/BwDuDhHJAP54B8OAfMS3XAvFQH8HAO4OEckA/ngHw4B8xLdcC8VAfwcA7g4RyQD+eAfDgHzEt1wLxUB/BwAeDhApAPF4B8uADMS43DAWsE4FolYI0CrNGANfb37QGYlxoAHi4APFwA8uECkA8XgHmpAZiXGgAeLgA8XADy4QKQDxeAeakBmJcaAB4uADxcAPLhApAPF4B5qQGYlxoAHi4APFwA8uECkA8XgHmpAZiXGgAeLgA8XADy4QKQDxeAeakBmJcaAB4uADxcAPLhApAPF4B5qQGYlxoAHi4APFwA8uECkA8XgHmpAZiXGgAeLgA8XADy4QKQDxeAeakBmJcaAB4uADxcAPLhApAPF4B5qQGYlxoAHi4APFwA8uECkA8XgHmpAZiXGgAeLgA8XADy4QKQDxeAeakBmJcaAB4uADxcAPLhApAPF4B5qQGYlxoAHi4APFwA8uECkA8XgHmpAZiXGgAeLgA8XADy4QKQDxeAeakBmJcaAB4uADxcAPLhApAPF4B5qQmYl5oAHi4BPFwC8uHycMAaAfjME7BGAa5VA9bY/zxPQD5cAualJmBeagJ4uATwcAnIh0tAPlwC5qUmYF5qAni4BPBwCciHS0A+XALmpSZgXmoCeLgE8HAJyIdLQD5cAualJmBeagJ4uATwcAnIh0tAPlwC5qUmYF5qAni4BPBwCciHS0A+XALmpSZgXmoCeLgE8HAJyIdLQD5cAualJmBeagJ4uATwcAnIh0tAPlwC5qUmYF5qAni4BPBwCciHS0A+XALmpSZgXmoCeLgE8HAJyIdLQD5cAualJmBeagJ4uATwcAnIh0tAPlwC5qUmYF5qAni4BPBwCciHS0A+XALmpSZgXmoCeLgE8HAJyIdLQD5cAualJmBeagJ4uATwcAnIh0tAPlwC5qUmYF5qAni4BPBwCciHS0A+XALmpSZgXmoCeLgE8HAJyIcrQD5cAealFmBeagF4uDocsEYA1kjAGgX4zBuwBmCfA3i4AuTDFSAfrgDzUgswL7UAPFwBeLgC5MMVIB+uAPNSCzAvtQA8XAF4uALkwxUgH64A81ILMC+1ADxcAXi4AuTDFSAfrgDzUgswL7UAPFwBeLgC5MMVIB+uAPNSCzAvtQA8XAF4uALkwxUgH64A81ILMC+1ADxcAXi4AuTDFSAfrgDzUgswL7UAPFwBeLgC5MMVIB+uAPNSCzAvtQA8XAF4uALkwxUgH64A81ILMC+1ADxcAXi4AuTDFSAfrgDzUgswL7UAPFwBeLgC5MMVIB+uAPNSCzAvtQA8XAF4uALkwxUgH64A81ILMC+1ADxcAXi4AuTDFSAfrgDzUgswL7UAPFwBeLgC5MMVIB+uAPNSCzAvtQA8XAF4uALkwxUgH64A81ILMC+1ADxcA3i4BuTDNSAfrgHzUvtwwBoBuFYJWKMAazRgjf19ewPmpTaAh2sAD9eAfLgG5MM1YF5qA+alNoCHawAP14B8uAbkwzVgXmoD5qU2gIdrAA/XgHy4BuTDNWBeagPmpTaAh2sAD9eAfLgG5MM1YF5qA+alNoCHawAP14B8uAbkwzVgXmoD5qU2gIdrAA/XgHy4BuTDNWBeagPmpTaAh2sAD9eAfLgG5MM1YF5qA+alNoCHawAP14B8uAbkwzVgXmoD5qU2gIdrAA/XgHy4BuTDNWBeagPmpTaAh2sAD9eAfLgG5MM1YF5qA+alNoCHawAP14B8uAbkwzVgXmoD5qU2gIdrAA/XgHy4BuTDNWBeagPmpTaAh2sAD9eAfLgG5MM1YF5qA+alNoCHawAP14B8uAbkwzVgXmoD5qU2gIdrAA/XgHy4BuTDNWBe6gDmpQ6AhxsADzeAfLg5HLBGAD7zBKxRgGvVgDX2P88HkA83gHmpA5iXOgAebgA83ADy4QaQDzeAeakDmJc6AB5uADzcAPLhBpAPN4B5qQOYlzoAHm4APNwA8uEGkA83gHmpA5iXOgAebgA83ADy4QaQDzeAeakDmJc6AB5uADzcAPLhBpAPN4B5qQOYlzoAHm4APNwA8uEGkA83gHmpA5iXOgAebgA83ADy4QaQDzeAeakDmJc6AB5uADzcAPLhBpAPN4B5qQOYlzoAHm4APNwA8uEGkA83gHmpA5iXOgAebgA83ADy4QaQDzeAeakDmJc6AB5uADzcAPLhBpAPN4B5qQOYlzoAHm4APNwA8uEGkA83gHmpA5iXOgAebgA83ADy4QaQDzeAeakDmJc6AB5uADzcAPLhBpAPN4B5qQOYlzoAHm4APNzsz4ezY38+3LnG9r79XEMBaxjgWjlgjQCskYA1CvCZN2ANwD4XwD7fnw93rqGANWz/Z75/Xuq5BmCfC2Cf78+HO9dowBqz/zPfPy/1XAOwzxWwzxXwPN+fD3euEYDPPAFrAPa5Ava5Ap7nBnieG6BvN0DfboB9boB9boDnuQGe5wbo2w3Qtxtgnztgnzvgee6A57kD+vb981LPNQD73AH73AHPcwc8zx3Qtwegbw/APg/APg/A83x/Pty5BqBvD0DfHoB9HoB9HoDneQKe5wno2xPQtydgnydgnyfgeZ6A53kC+vYE9O0J2OcF2OcFeJ4X4HlegL59/7zUcw3APi/APi/A87wAz/MC9O0N6NsbsM8bsM8b8Dzfnw93rgHo2xvQtzdgnzdgnzfgeT6A5/kA+vYB9O0D2OcD2OcDeJ4P4Hk+gL59AH07gIcTAA8n+/PhzjUUsMb+vl0OB6wRgGuVgDUKsEYD1tjft8v+eannGoB9DuDhZH8+3LmGA9YIwGeegDUA+xzAw4kAnucKeJ7vn5d6rqGANQD7HMDDiQKe5wp4nu+fl3qu0YA1APscwMOJAZ7nBnieG6Bv3z8v9VwDsM8BPJwY4HlugOe5Afp2B/TtAB5OADycOOB5vj8f7lwD0Lc7oG8H8HAC4OHEAc/zADzPA9C3B6BvB/BwAuDhJADP8wA8zwPQtwegbwfwcALg4SQBz/MEPM8T0Lfvn5d6rgHY5wAeThLwPE/A8zwBfXsB+nYADycAHk4K8Dzfnw93rgHo2wvQtwN4OAHwcFKA53kDnucN6Nsb0LcDeDgB8HDSgOd5A57nDejbG9C3A3g4AfBwMoDn+QCe5wPo2/fPSz3XAOxzAA8nA3ieD+B5vn9equn+eannGvv3uQJ4OAXkw+nhgDUC8JknYI0CXKsGrLH/ea6AfDjdPy/1XEMBawD2OYCHU0A+nALy4XT/vNRzjQasAdjnAB5OAflwCsiH0/3zUs81HLAGYJ8DeDgF5MMpIB9OFdC3G6BvB/BwCuDhFJAPp4B8ODVA326Avh3AwymAh1NAPpwC8uHUAX27A/p2AA+nAB5OAflwCsiHUwf07Q7o2wE8nAJ4OAXkwykgH04D0Lfvn5d6rgHY5wAeTgH5cArIh9MA9O0J6NsBPJwCeDgF5MMpIB9OE9C3J6BvB/BwCuDhFJAPp4B8OC1A316Avh3AwymAh1NAPpwC8uG0AH17Afp2AA+nAB5OAflwCsiH0wb07fvnpZ5rAPY5gIdTQD6cAvLhtAF9+wD6dgAPpwAeTgH5cArIh9MB9O0D6NsBPJwCeDgF5MMZIB/OAPNSDTAv1QA8nB0OWCMAayRgjQJ85g1YA7DPATycAfLhDJAPZ4B5qQaYl2oAHs4APJwB8uEMkA9ngHmpBpiXagAezgA8nAHy4QyQD2eAeakGmJdqAB7OADycAfLhDJAPZ4B5qQaYl2oAHs4APJwB8uEMkA9ngHmpBpiXagAezgA8nAHy4QyQD2eAeakGmJdqAB7OADycAfLhDJAPZ4B5qQaYl2oAHs4APJwB8uEMkA9ngHmpBpiXagAezgA8nAHy4QyQD2eAeakGmJdqAB7OADycAfLhDJAPZ4B5qQaYl2oAHs4APJwB8uEMkA9ngHmpBpiXagAezgA8nAHy4QyQD2eAeakGmJdqAB7OADycAfLhDJAPZ4B5qQaYl2oAHs4APJwB8uEMkA9ngHmpBpiXagAezgA8nAHy4QyQD2eAeakGmJdqAB7OATycA/LhHJAP54B5qX44YI0AXKsErFGANRqwxv6+3QHzUh3AwzmAh3NAPpwD8uEcMC/VAfNSHcDDOYCHc0A+nAPy4RwwL9UB81IdwMM5gIdzQD6cA/LhHDAv1QHzUh3AwzmAh3NAPpwD8uEcMC/VAfNSHcDDOYCHc0A+nAPy4RwwL9UB81IdwMM5gIdzQD6cA/LhHDAv1QHzUh3AwzmAh3NAPpwD8uEcMC/VAfNSHcDDOYCHc0A+nAPy4RwwL9UB81IdwMM5gIdzQD6cA/LhHDAv1QHzUh3AwzmAh3NAPpwD8uEcMC/VAfNS/Qc8XMr3NWw+X2M66i9/PF3+bgXdvoJtX8G3rxB//woT/W2F6fcr5PYVavsKvX2F2b3CD+i3Z64g21fQ7SvY9hV8+wrb93Rv39O9fU/39j3d2/f0bN/Ts31Pz/Y9Pdv39Gzf07N9T8/2PT3b9/Rs39Oze0/HcWxfQbavoNtXsO0r+PYVYvsKuX2F2r5Cb19h+56W7Xtatu9p2b6nZfuelu17Wrbvadm+p2X7npbte1q272ndvqd1+57W7Xtat+9p3b6ndfue1u17Wrfvad2+p3X7nrbte9q272nbvqdt+5627Xvatu9p276nbfuetu172rbvad++p337nvbte9q372nfvqd9+5727Xvat+9p376nffueju17Orbv6di+p2P7no7tezq27+nYvqdj+56O7Xs6tu/p3L6nc/uezu17Orfv6dy+p3P7ns7tezq37+ncvqdz+56u7Xu6tu/p2r6na/ueru17ejtHFts5stjOkcV2jiy2c2SxnSOL7RxZbOfIYjtHFts5stjOkcV2jiy2c2SxnSOL7RxZbOfIYjtHFts5stjOkcV2jiy2c2SxnSOL7RxZbOfIYjtHlts5stzOkeV2jiy3c2R5+PYVYvsKuX2F2r5Cb19h+57ezpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo6stnNktZ0jq+0cWW3nyOrw7SvE9hVy+wq1fYXevsL2Pb2dI6vtHFlt58hqO0dW2zmy2s6R1XaOrLZzZLWdI6vtHFlt58hqO0dW2zmy2s6R1XaOrLZzZLWdI6vtHFlt58hqO0dW2zmy2s6R1Y84spS3FVouVmh5W6H9eLeCbV/Bn7DCZ3M46kcc2RNXyO0r1PYV+u9f4eLbOrtX+BFHtrRCyfcV7N0Ksn0F3X6VbPs5+PYVYvtVyu3nUNtX2L6nfXafQ2zf0yG7r1Lo9nPYvqfDt1+l2H4O2/d01Par1NvPYfuezmP3Vcrtz+ncvqfTtl+l7c/p3L6nM7dfpe3P6dy+p3N7713bn9O1fU/X9t67tj+na/ueru29d21/Ttf2PV3be+/a/pzu7Xu6t/fevf053dv3dG/vvXv7c7q37+ne3nv39ud0b9/Ts733nu3P6dm+p2d77z3bn9OzfU/P9t57tj+nZ/uent29dx+7n9N9yPYVdPtVsu3n4NtXiO1XKbefQ21fobdfpd3P6Zbte1p2994tuv0ctu9p8e1XKbafw/Y9LbX9KvX2c9i+p3V37926/Tmt2/e02vartP05rdv3tOb2q7T9Oa3b97Ru771t+3Patu9p2957/4gjm28HSdlxsULktwW63/5U5y8LfLyly/Jtgey/a4GPd/Spt39b4PyB8Xct8PGGniO+LTD2Hxb4P0fVQ0d9vPG69PtR/vnJyOTbZzdd3//Y/7LEbF/iB7jXU5eQ/Uvo372Ehhx/+WONiPdL2P4lfP8SsX+J3L9E7V+i9y8x25eIY/8Ssn+J/bs79u/u2L+7Y//ujv27O/bv7ti/u2P/7s5n7O63plZjPlhC9i+h+5ew/Us8YXefb2q+LXHeLX6/xPs/7vJv9Zz/+L4jygDXE/ntj8/dVZ//sbj7m4HHPT+4nHnv8gtcfr79hOqc4309TVbPcNVTB1k9wnU3KUXXY8dbPf/xj/9PPUZWj9/6dlX3flhUku1esrt/kd39i+zu3wfX3baF6+7WZHf/ht/9297qmXlfj5PVE2T1JFk9RVZP3/rx23Pr8oes9x8hq0fJ6jGyepyre5jgelpPktVDdvefJqtnqOqZ4yCrR8jqUbJ6uLrzOdD3Zz++/ZfbTd7XE2T1JFk9ded2co5bN/NzcGkzI1zd+QhXdz7C1Z2PGFU3POJU3ecIV3c+wqXNjHB15yNc3fkIWXeuZN25knXnStadq926PVG/d/nB9bRWrjeno1xvTke53pyODld3ZQdXN2Ncb07HyO7+RqbNmJPVw/XmdIysOzey7tzIunO79avQ8ePe5ZNpM06mzTjXm9NxJ6snuLor53pzOl5k9ZDd/Z1MmwkybSbItJkg686DrDsPJ6vn1pj6xK09TRNk2kyQaTNB9uY0yd6cJpenaZKLap/k8jRNkt39k0ybSTJtJsm0mSTrzpOsOy+y7hzuOf09Bybv7z9wz+lVPUZWj5PVE2T1JFk9RVZPk9UzXPXAXaFX9ZDdn5vs/txk9+cmuz832f25ye7PTXZ/brL7c5Pdn+dn3p8/8C2MkNWDvj8/V26ce4OKcFfohfo2ZOThkJGHQ6Zu412hn6uleFfoZ+qkHwcVeXjWQ/Vu86yH6t3mWQ/Vu82zHierh0rdPuuhUrfPeqjU7bOeO9s8z/LvDCr6weUKPeuhIg/PeqjIw7MeKvLwrMeZuquzHipX6FkPFXl41kN29+dyhZ71UL3bPIUJqnebZz1k3TmXK/Ssh6w7v7XN8yz/zqDiWT6VNnPWQ6XNnPVQkYdnPVTkoR9Glad71kPlCj3roSIPz3rI7v5crtCzHjJthssVetZD1p1zuULPesi681vbPM/y5d7lk2kzXK7Qsx4nq4fqzelZT3J1V1yu0LOeJquH7O7P5Qo96yHTZrhcoWc9ZN05lyv0rIesOw8qrvGsh4prPOuh4hrPeqi4Rj+Sims866HiGs964Nx5vPVjHu/3O9y3eVWPk9UTZPXc2YZ/ln/nePSzfDLtnGsSqR9ck0jPesjIFvwk0s9//XJNIj3rcbJ6yLrzItPOi0w7LzLtvMjUkyZTT5pMPek7u47O8u/sOjrLd66ndZNp501GtjQZ2dJUrqOzHjLX0ZC5jobs7j9k2vmQaef4WaEX9ZB150PWnXPNCj3rubfraG7tOpKDS5uRg0ubkYOLbJGDi2yRw6m6Kzm4XEdycLmOhMxzKgeXNiMHlzYjwqXNiHB15yJc3bkIV3cucFfoc9sTubXrSIRLmxHh0mZEuN6cinC9ORXlch2JcrmORLlcR0LmORW45/SqHi5tRpRLmxEl686VrDtXsu7cqPJ0z3qo8nTPeqjydM96qPJ0z3qcrJ6fmaf7nosVS7J64Nz5p9ynwF2hV/UMVz1wV+hVPbe2eYrfGoQRMleokLlChcwVKk6mnuBdoZ//GidzhYpzkS1C5goVMleokLlChcwVKmSuUCFzhUqQqSdxaxuRxK1BGOGaFerCNSv0rIeMbEkysgU/K/Tz7go/K/TzbibJyBauWaFnPWTaOdes0LMeMu2ca1boWQ9Zd15k3Xnd2kYkcBPpk8sn02aKTJspMrKlyMgWvOf08+6quVxH0mRkS5Pd/ZtMm4G7Qq/qIdNmmqw7b7LuvMm68763jWhuHb8rQ6bNDJk2M2RvTrkmkZ71BFd3NWSuo+HK05Uhu/sPlzajB5c2o2STSJVsEqmSTSLVg6s71+Nnco3vOUs9uPJ09eDK09WDK09XD648XRWuPF0VrjxdFa48XRWuPF2Fu0Kv6uHK01W5dZ6uyq1BGCVzhSqZK1SVi2xR5VJPVLnydFW58nQV7wq9qIdLO1cyV6iSuUKVzBWqZK5QNTL1xMjUE7u1jUjt1iCMwj2nF09r4yJb1LjIFjUuskWNK09Xjct1pM5FtqiT3f2dTDt3Mu0c7gq9qoesO3ey7tzJunO/tY1I/dYgjAaZNhNk2kxwkS0aXGSL4j2nn3dXweU60uAiWzTI7v5Bps0EmTaTZNpMknXnSdadJ1l3DneFPrc9yVvn6WqSaTNJps2QTSJVskmkWlx5ulpcriMtrjxdLbK7P34S6UU9ZNoM2SRSJZtEqmSTSJVsEqk2V56uNleerjZXnq42V56uwl2hV/Vw5elqc+XpanPl6Wpz5elqc+Xp6nDl6ercOk9X594gDJkrVMlcoTpkZMuQqSfDlaerw5Wnq8NFthiZK9TIXKFG5go1MleoHU5WD5d6YgeXemLHrW1EdtwahLGDSzs34SJbTLjIFhMussWEK0/X4J7Ti25GuMgWE7K7v3Bp5yZc2rkJl3ZuStadK1l3rmTdud7aRmRwE+mTy+fSZky5tBlTLrLFlItsMeXK0zXjch2ZcZEtZmR3fyPTZuCu0Kt6yLQZI+vOjaw7N7Lu3G5tIzK/dZ6uOZk242TaDNkkUiObRGrOladrzuU6MufK0zUnu/s7mTZDNonUyCaRGtkkUiObRGpkk0gtuPJ0LbjydC248nQtuPJ0LbjydC258nQtufJ0LbnydC258nQN7gq9qocrT9fy1nm6lvcGYchcoUbmCrUiI1uKTD0prjxdK648XcO7Qi/qIdPOyVyhRuYKNTJXqJG5Qq3J1JMmU0/61jYi63uDMHDP6cXTusnIliYjW5qMbGmuPF1rMtfRkJEtQ3b3HzLtfMi0c7gr9Koesu58yLrzIevO5942ork1COMHlzbjB5c24wcX2eIHF9nih1N1V35wuY784CJb/OC6+/vBpc34waXNuHBpMy5c3bkLV3fuwtWdO9wV+tz2RG6dp+vCpc24cGkzTjaJ1Mkmkbpy5em6crmOXLnydF3J7v74SaQX9XBpM042idTJJpE62SRSJ5tE6saVp+vGlafrxpWn68aVp+twV+hVPVx5um5cebpuXHm6blx5um5cebruXHm67rfO03W/NQjjZK5QJ3OFunORLe5k6olz5em6c+XpunORLU7mCnUyV6iTuUKdzBXqZK5QDzL1JMjUk7i1jcjj1iCMB5l2nmRkS5KRLUlGtiRXnq7DPacX3UySkS1JdvdPMu08ybTzJNPOi6w7L7LuvMi687q1jcjhJtInl0+mzRSZNlNkZEuRkS3FlafrzeU68iYjW5rs7t9k2gzcFXpVD5k202TdeZN1503Wnfe9bURz6zxdHzJtZsi0GbJJpE42idSHK0/Xh8x1NFx5uj5kd//h0maCbBJpkE0iDbJJpEE2iTQOru48Dq483Ti48nTj4MrTjYMrTzcOrjzdEK483RCuPN0QrjzdEK483YC7Qq/q4crTDbl1nm7IrUGYIHOFBpkrNJSLbAnlUk9CufJ0Q7nydAPvCr2oh0s7DzJXaJC5QoPMFRpkrtAwMvXEyNQTu7WNKOzWIEzAPacXT2vjIlvCuMiWMC6yJYwrTzeMy3UUzkW2hJPd/Z1MO3cy7RzuCr2qh6w7d7Lu3Mm6c7+1jSj81iBMBJk2E2TaTHCRLRFcZEvgPaefd1fB5TqK4CJbIsju/kGmzQSZNpNk2kySdedJ1p0nWXcOd4U+tz3JW+fpRpJpM0mmzZBNIg2ySaRRXHm6UVyuoyiuPN0osrs/fhLpRT1k2gzZJNIgm0QaZJNIg2wSaTRXnm40V55uNFeebjRXnm7AXaFX9XDl6UZz5elGc+XpRnPl6UZz5enGcOXpxtw6Tzfm3iAMmSs0yFyhMWRky5CpJ8OVpxvDlacbw0W2JJkrNMlcoUnmCk0yV2geTlYPl3qSB5d6ksetbUR53BqEyYNLO0/hIltSuMiWFC6yJYUrTzfhntOLbka4yJYUsru/cGnnKVzaeQqXdp5K1p0rWXeuZN253tpGlHAT6ZPL59JmUrm0mVQusiWVi2xJ5crTTeNyHaVxkS1pZHd/I9Nm4K7Qq3rItBkj686NrDs3su7cbm0jSr91nm46mTbjZNoM2STSJJtEms6Vp5vO5TpK58rTTSe7+zuZNkM2iTTJJpEm2STSJJtEmmSTSDO48nQzuPJ0M7jydDO48nQzuPJ0M7nydDO58nQzufJ0M7nydBPuCr2qhytPN/PWebqZ9wZhyFyhSeYKzSIjW4pMPSmuPN0srjzdxLtCL+oh087JXKFJ5gpNMldokrlCs8nUkyZTT/rWNqLse4MwcM/pxdO6yciWJiNbmoxsaa483Wwy19GQkS1DdvcfMu18yLRzuCv0qh6y7nzIuvMh687n3jaiuTUIUweXNlMHlzZTBxfZUgcX2VKHU3VXdXC5jurgIlvq4Lr718GlzdTBpc2UcGkzJVzdeQlXd17C1Z0X3BX63PZEbp2nW8KlzZRwaTNFNom0yCaRlnLl6ZZyuY5KufJ0S8nu/vhJpBf1cGkzRTaJtMgmkRbZJNIim0RaxpWnW8aVp1vGladbxpWnW3BX6FU9XHm6ZVx5umVcebplXHm6ZVx5uuVcebrlt87TLb81CFNkrtAic4WWc5Et5WTqiXPl6ZZz5emWc5EtReYKLTJXaJG5QovMFVpkrtAKMvUkyNSTuLWNqOLWIEwFmXaeZGRLkpEtSUa2JFeebsE9pxfdTJKRLUl2908y7TzJtPMk086LrDsvsu68yLrzurWNqOAm0ieXT6bNFJk2U2RkS5GRLcWVp1vN5TqqJiNbmuzu32TaDNwVelUPmTbTZN15k3XnTdad971tRHPrPN0aMm1myLQZskmkRTaJtIYrT7eGzHU0XHm6NWR3/+HSZppsEmmTTSJtskmkTTaJtA+u7rwPrjzdPrjydPvgytPtgytPtw+uPN0WrjzdFq483RauPN0WrjzdhrtCr+rhytNtuXWebsutQZgmc4U2mSu0lYtsaeVST1q58nRbufJ0G+8KvaiHSztvMldok7lCm8wV2mSu0DYy9cTI1BO7tY2o7dYgTMM9pxdPa+MiW9q4yJY2LrKljStPt43LddTORba0k939nUw7dzLtHO4KvaqHrDt3su7cybpzv7WNqP3WIEwHmTYTZNpMcJEtHVxkS+M9p593V8HlOurgIls6yO7+QabNBJk2k2TaTJJ150nWnSdZdw53hT63Pclb5+l2kmkzSabNkE0ibbJJpF1cebpdXK6jLq483S6yuz9+EulFPWTaDNkk0iabRNpkk0ibbBJpN1eebjdXnm43V55uN1eebsNdoVf1cOXpdnPl6XZz5el2c+XpdnPl6fZw5en23DpPt+feIAyZK7TJXKE9ZGTLkKknw5Wn28OVp9vDRbYMmSt0yFyhQ+YKHTJX6BxOVg+XejIHl3oyx61tRHPcGoSZg0s7H+EiW0a4yJYRLrJlhCtPd+Ce04tuRrjIlhGyu79waecjXNr5CJd2PkrWnStZd65k3bne2kY0cBPpk8vn0mZGubSZUS6yZZSLbBnlytMd43IdjXGRLWNkd38j02bgrtCresi0GSPrzo2sOzey7txubSMav3We7jiZNuNk2gzZJNIhm0Q6zpWnO87lOhrnytMdJ7v7O5k2QzaJdMgmkQ7ZJNIhm0Q6ZJNIJ7jydCe48nQnuPJ0J7jydCe48nQnufJ0J7nydCe58nQnufJ0B+4KvaqHK0938tZ5upP3BmHIXKFD5gqdIiNbikw9Ka483SmuPN3Bu0Iv6iHTzslcoUPmCh0yV+iQuUKnydSTJlNP+tY2oul7gzBwz+nF07rJyJYmI1uajGxprjzdaTLX0ZCRLUN29x8y7XzItHO4K/SqHrLufMi68yHrzufeNqK5MwgTx0GlzZz1UGkzZz1UZMtZDxXZctbjTN3VWQ+V6+ish4psOeuhuvuf9VBpM2c9VNpMHEKlzZz1UHXnZz1U3flZD1V3ftbjt25P5M55umf5VNrMWQ+VNnPWQ/Xm9KyH6s1pHEqVp3vWQ+U6OuuhytM96yG7++MnkV7UQ6XNnPVQaTNnPWTdOdck0rMesu7cqPJ0z3qo8nTPeqjydM96fmae7jvu86zHyeohuz8/wRVqenzr0U3tfYv+BKPn5RK9f4nZvsQTLJOmEW9L9Pv28gm2xssldP8Stn8J379E7F8i9y9R+5fo/UvM9iWe4aAL+fbj6Fzs/Q3kGaa4qyV0/xK2fwnfv0TsXyL3L1H7l+j9S8z2JXL/7s79uzv37+7cv7tz/+7O/bs79+/u3L+7n+HciZK3JeaDJWb7Es/w11wtIfuXoHLBnPXcGZs+y/d7l09FWZ/1kL3JK7I3eUX2Jq+o8gPjaCrK+qyH7E3erT02Z/n3flhweWzOesju/lwem7Mesrs/l8fmrIfKYxMHl8fmrIeM4uPy2Jz1kHEcXB6bsx6y94Rz5/yTs/w755+c5ZP1/sNF8QmZx0bIPDZycCk/clDln5z1OFk9XHd/4ZrrdtbDRfEJmcdGyDw2QuaxETKPjcjPpPjeU2oiXBSfwD02V/UEWT237s5Fbt2dC5nHRsg8NqJk3bmSdedK1p0rWXeO99hc1EPWnZN5bITMYyNkHhsh89iIkXXnRtad263fnIrd+s2pwB08F09r43pzKsb15lSM682pGNebUzGuN6fiXG9Oxcnu/s715lSc682pwCevXdVD1p07WXfuZN253zmd8Cz/1umEEmTaTJBpM8GVTijBlU4o+Llun3dXwZVOKMGVTihBdvcPMm0myLSZJNNmkqw7T7LuPMm6c/hct+e2J3nrdEJJMm0mybQZrrluZz1kb06LK51QisvTJMWVTihFdvfHz3W7qIdMm+Ga63bWQ9adc811O+sh686bK51QmiudUJornVDayOpxsnqCrJ4kq6fI6mmyeoarniG7Pw/Z/XnI7s9Ddn8esvvzkN2fh+z+PGT35/mZ9+cPfAIzVPUo3Lf5VHlP4TbPJ5fP9W5TySav6eFk9XCRh4p3hX6qTireFfqpGqh4V+hFPVzqiZK5QpXMFapkk9eUbPKawl2hV/Vwqdt6b1eo3tsVqmSuUCVzhSqZK1TJXKFK5gpVMleokrlClcwVqmSuUCVzhSqZK1TJXKFK5gpVMleo3tsVqvd2hSqZK1TJXKFK5gpVMleokrlClcwVqmSuUCVzhSqZK1TJXKFK5gpVMleokrlClcwVqvd2heq9XaFK5gpVMleokrlClcwVqmSuUCVzhSqZK1TJXKFK5gpVMleokrlClcwVqmSuUCVzhSrcFfo5J6fJxTVqcnGNmlxcoyYX16hJxjXCfZseb/2Yx/v9DvdtXtWjZPUYWT1+65+PdWvXvpJNIlWySaRKNolUi4xsaS7XvpJNItXmcu1rk3XncFfoVT1k2nmTaedNpp40mXrSZOrJ3Nt1NPd2HQ2Zdj5k2jncc3pVDxnZMmSuoyFzHQ2Z62i47v52cGnndnBp53Zwaed2cHXndnB150Y2K9SOW7uO7Li168gOLm3GDi5txoSLbDHhIltMuFxHJlyuI8N7Ti/qIbv7C5c2Y8KlzZhwaTMmZN25knXnStad661dR6a3dh0Z3HN68bRWLm3GlOvNqSnXm1NTLteRKZfryIzLdWRknlMzMm3GyLQZuCv0qh6y7tzIunMj686NK0/XjCtP15wrT9ecK0/XnCtP1/xn5um+52IN7gq9qgfOnX/KfRrcFXpVT5HV02T13NrmaXFrEMbIXKFG5go1MleowV2hV/UE169xMleoBRfZYmSuUCNzhRqZK9TIXKFG5go1MleowV2hV/Xc2kZkeW8QhmxWqJHNCjWyWaFWZGQLflbo590V2axQKzKyhWxWqJHNCjWyWaFGNivUyGaFGtmsUGuy7rxvbSOyvjcI02TaDNxzelUPGdnSZGQL3nP6eXfVXK4jazKyZcju/kOmzQyZNjNk2gzcFXpVD1l3PmTd+dzbRjS3jt+14dJm/ODSZvzgenPqZJNIHe85/bS78sOpuhk/uPJ0/eC6+/vBpc34waXNONkkUiebROpkk0idbBKpy8/kGt9zlg53hV7Vw5Wn68KVp+vClafrwpWn68KVp+vKlafrypWn68qVp+vKlafrcN/mU3/Out4ahHEyV6iTuUJducgWVzL1xLjydN248nTduMgWJ3OFOpkr1MlcoU7mCnUyV6gbmXpiZOqJ39pG5H5rEMadTDt3LrLF4Z7Tq3q4yBZ3rjxddy7XkTsX2eJOdvcPMu08yLTzINPOg6w7x88KvaiHrDuPW9uIPG4NwniQaTNBps0kGdmSZGRLcuXpenK5jhzvOb2oh+zun2TaTJJpM0mmzSRZd15k3XmRded1axuR163zdB3uOb14WheZNkM2idTJJpF6ceXpenG5jry58nS9ye7+TabNkE0idbJJpE42idTJJpE62SRSb648XW+uPF0frjxdH648XR+uPF0frjxdh7tCr+rhytP14crT9eHK0/XhytP1uXWebhy3BmGCzBUaZK7QOLjIljicrB6uPN04uPJ04+AiW4LMFRpkrtAgc4UGmSs0yFyhIVzqSeBnhV7Uc2sbUcitQZgQLu08hItsCeEiW0K5yJZQrjzdUC7XUSgX2RJKdvdXLu08lEs7D+XSzkPJunMl686NrDu3W9uIwm4NwoSRaTNwz+lVPVxkSxgX2RLGlacbxuU6CuMiW8LJ7v5Ops04mTbjZNoM3BV6VQ9Zd+5k3bnf2kYUfus83XAybSbItBmySaRBNok0gitPN/Ce08+7meDK040gu/sHmTZDNok0yCaRBtkk0iCbRBpkk0gjufJ0A+4KvaqHK083kitPN5IrTzeSK083kitPN4orTzeKK083iitPN4orTzfgvs3n/pyte4MwZK7QIHOFRpGRLUWmnjRXnm40V55uNBnZQuYKDTJXaJC5QoPMFRpkrtBoMvWkydSTubeNaO4NwgyZdj5kZAvcc3pVDxnZMlx5ujFkrqMhI1uG6+6fB5d2ngeXdp4Hl3aeB1d3ngdXd54HV3eex61tRHncGoTJg0ubyYNLm0nhIltSuMiWFK483RQu11HiPacX9ZDd/YVLm0nh0mZSuLSZFLLuXMm6cyXrzvXWNqLUW+fpJtxzevG0Vi5tJskmkSbZJNJUrjzdVC7XURpXnm4a2d3fyLQZskmkSTaJNMkmkSbZJNIkm0SaxpWnm8aVp5vOlaebzpWnm86Vp5vOlaebcFfoVT1cebrpXHm66Vx5uulcebrpt87Tzbg1CJNkrtAkc4VmcJEtCXeFXtXDlaebwZWnm8FFtiSZKzTJXKFJ5gpNMldokrlCM8nUE/ys0It6bm0jyrw3CJNk2nmSkS1JRrYUGdlSXHm6WVyuoywysqXI7v5Fpp0XmXZeZNp5kXXnRdadN1l33re2EWXfG4RpMm0G7jm9qoeMbGkysqW58nSzuVxH2WRky5Dd/YdMmxkybWbItBm4K/SqHrLufMi687m3jWhunaebw6XN1MGlzRTZJNIim0RaB1eebh1O1c3UwZWnWwfX3b8OLm2myCaRFtkk0iKbRFpkk0iLbBJpCVeebsFdoVf1cOXplnDl6ZZw5emWcOXplnDl6ZZy5emWcuXplnLl6ZZy5ekW3Lf51J+zpbcGYYrMFVpkrtBSLrKllEw9Ma483TKuPN0yLrKlyFyhReYKLTJXaJG5QovMFVpGpp4YmXrit7YRld8ahCkn086di2wpuOf0qh4usqWcK0+3nMt1VM5FtpST3f2DTDsPMu08yLTzIOvO8bNCL+oh687j1jaiiluDMBVk2kyQaTNJRrYkGdmSXHm6lVyuo8J7Ti/qIbv7J5k2k2TaTJJpM0nWnRdZd15k3Xnd2kZUdes83YJ7Ti+e1kWmzZBNIi2ySaRVXHm6VVyuo2quPN1qsrt/k2kzZJNIi2wSaZFNIi2ySaRFNom0mitPt5orT7eGK0+3hitPt4YrT7eGK0+34K7Qq3q48nRruPJ0a7jydGu48nRrbp2n28etQZgmc4U2mSu0Dy6ypQ8nq4crT7cPrjzdPrjIliZzhTaZK7TJXKFN5gptMldoC5d60vhZoRf13NpG1HJrEKaFSztv4SJbWrjIllYusqWVK0+3lct11MpFtrSS3f2VSztv5dLOW7m081ay7lzJunMj687t1jaitluDMG1k2gzcc3pVDxfZ0sZFtrRx5em2cbmO2rjIlnayu7+TaTNOps04mTYDd4Ve1UPWnTtZd+63thG13zpPt51MmwkybYZsEmmTTSLt4MrTbbzn9PNuJrjydDvI7v5Bps2QTSJtskmkTTaJtMkmkTbZJNJOrjzdhrtCr+rhytPt5MrT7eTK0+3kytPt5MrT7eLK0+3iytPt4srT7eLK0224b/O5P2fr3iAMmSu0yVyhXWRkS5GpJ82Vp9vNlafbTUa2kLlCm8wV2mSu0CZzhTaZK7SbTD1pMvVk7m0jmnuDMEOmnQ8Z2QL3nF7VQ0a2DFeebg+Z62jIyJbhuvvPwaWdz8Glnc/BpZ3PwdWdz8HVnc/B1Z3PcWsb0Ry3BmHm4NJm5uDSZka4yJYRLrJlhCtPd4TLdTR4z+lFPWR3f+HSZka4tJkRLm1mhKw7V7LuXMm6c721jWj01nm6A/ecXjytlUubGbJJpEM2iXSUK093lMt1NMaVpztGdvc3Mm2GbBLpkE0iHbJJpEM2iXTIJpGOceXpjnHl6Y5z5emOc+XpjnPl6Y5z5ekO3BV6VQ9Xnu44V57uOFee7jhXnu74rfN0J24NwgyZK3TIXKETXGTLwF2hV/Vw5elOcOXpTnCRLUPmCh0yV+iQuUKHzBU6ZK7QSTL1BD8r9KKeW9uIJu8NwiSZdp5kZEuSkS1FRrYUV57uFJfraIqMbCmyu3+RaedFpp0XmXZeZN15kXXnTdad961tRNP3BmGaTJuBe06v6iEjW5qMbGmuPN1pLtfRNBnZMmR3/yHTZoZMmxkybQbuCr2qh6w7H7LufO5tI5pb5+nOUGkzeRxU2sxZD9Wb07MeqjenZz1UebpnPc7UzZz1UOXpnvVQ3f3Peqi0mbMeKm3mrIdKm8mDaxLpWQ9Vd37WQ9Wdn/VQ5eme9ThZPVR5umc9VHm6Zz1UebpnPVR5umc9VHm6eShVnu5ZD1We7lkPVZ7uWQ9Vnu5Zj9/45+xZ/p1BmLN8Ku38rIeKbDnroSJbznrI1BOjytM966HK0z3roSJbznqotPOzHierh0o7P+shU0+4XKFnPWTqiZGpJ35nG9FZ/p1BmLN8Mu3cqciWsx4nq4eKbDnrocrTPeuhch2d9VCRLWc9ZHf/INPOg0w7DzLtPMi6c/ys0It6yLrzuLON6Cz/ziDMWT6ZNhNk2kySkS1JRrYkVZ7uWQ+V6+isx8nqIbv7J5k2k2TaTJJpM0nWnRdZd15k3Xnd2UZ0ln/nPN2zfOd6WheZNsM1ifSsh+zNaVHl6Z71ULmO8miqPN2zHrK7f5NpM1yTSM96nKwesu6caxLpWQ9Zd95UebpnPVR5unkMVZ7uWQ9Vnu5ZD1We7lkPVZ7uWY+T1UOVp3vWQ5Wne9ZDlad71kOVp3vWc+c83ZTj1iCMkLlChcwVKgcX2SKHk9VDlad71kOVp3vWw0W2CJkrVMhcoULmChUyV6iQuUJFuNQTwc8Kvajn1jYikVuDMCJc2rkIF9kiwkW2iHKRLaJUebpnPVyuI1EuskXgntOLu79yaeeiXNq5KJd2LkrWnStZd25k3bnd2kYkdmsQRoxMm4F7Tq/q4SJbxLjIFjGqPN2zHi7XkRgX2SJOdvd3Mm3GybQZJ9Nm4K7Qq3rIunMn68791jYi8Tvn6Z7lk2kzQabNcE0iPeshe3MaXHm6gvecft7NBFeergTZ3T/ItBmuSaRnPWTaDNck0rMesu6caxLpWQ9Xnq7AXaFX9XDl6Upy5elKcuXpSnLl6Upy5elKceXpSnHl6Upx5elKceXpCty3+dyfs3VvEIbMFSpkrlApMrKlyNST5srTlebK05UmI1vIXKFC5goVMleokLlChcwVKk2mnjSZejL3thHNvUGYIdPOh4xsgXtOr+ohI1uGK09Xhsx1NGRky3Dd/fXg0s714NLO9eDSzvXg6s714OrO9eDqzvW4tY1Ij1uDMHpwaTN6cGkzKlxkiwoX2aLClaerwuU6Urzn9KIesru/cGkzKlzajAqXNqNC1p0rWXeuZN253tpGpHrrPF2Fe04vntbKpc0o2SRSJZtEqsqVp6vK5TpS48rTVSO7+xuZNkM2iVTJJpEq2SRSJZtEqmSTSNW48nTVuPJ01bnydNV/Zp7ue+5TXcnqIbs/k7lC9QmuUDslzr/8sZ33+/dL5P4lav8SvX+J2b7EE2yNl0vIE5aIeFui3zftTzAfXi5h+5fw/UvE/iVy/xK1f4nev8RsXyKP/Uvs3925f3c/w40W8u2H87nY+9vgMwxmV0vE/iVy/xK1f4nev8RsX+IZlqqrJWT/Erp/if27u/bv7tq/u2v/7q79u7v27+7av7t7/+5+hgsmSt6WmA+W0P1L2P4lfP8SXJMMtO/NrPW9mbUmY9aajFkbMmZtyJi1IWPWhoxZgztKruq5tT1c594PiyFjIobs7j9cd387uO7+dnDNSbCDy01uB9fd3w743f/Td25G5lexg4uJsIOLiTCyKWZ23HqGpcmtzedG5lcx4XKTm3C5yQ3uV7mqh0v5MeGaYWnC5SY3Mr+KkflVjMyvYmR+FVMuYtmUi4gzsilmpj8zifU9wWiaZPUUWT1cSaym9+7O7d7duZF150bWnZNNMTOyKWZmZN25kXXnRtadG1l3bmTdOdkUMyObYmZkU8yMzK9iZH4V81u/OTW/9ZtTc643p+Zcb06NbIqZkU0xsyB7cxpkb06D7M1pkN39g+zNKdkUMyObYmZkU8yMbIqZkU0xs7x1sLblraOhLMm0GfiMtKt6uLKeLLmyniy5JsxbcuVwW3JlPVmR3f2LTJspMm2myLQZ+Iy0q3rIuvMi687r1iYlq1tPmDeyGWnWZNpMk705bbI3p801Yd7wM9I+72aaa8K8kc1IM7IZaUY2I83IZqTZkHXnQ9adD1l3PlwT5g3uOb2qh2vCvA3XhHkbrgnzNlxJrDZcSax+cCWx+iFk9ShZPVz3Zz+47s9+cN2f/eC6P/vBdX/2g+v+7AfZ/VnI7s/ClZTtwpWU7XLrwTQOt3k+uXyud5suXO82XbjIQxcu8tDxrtBP1UlXrjk2jneFXtTDpZ44mSvUyVyhrlzvNl251G1XLnXblUvd9nu7Qv3erlAnc4U6mSvUyVyhTuYKdTJXqJO5Qp3MFepkrlAnc4U6mSvUyVyhTuYKdTJXqJO5Qv3erlC/tyvUyVyhTuYKdTJXqJO5Qp3MFepkrlAnc4U6mSvUyVyhTuYKdTJXqJO5Qp3MFepkrlC/tyvU7+0KdTJXqJO5Qp3MFepkrlAnc4U6mSvUyVyhTuYKdTJXqJO5Qp3MFepkrlAnc4U6mSvUi4xrLDKusci4xibjGpuMa2wyrhHu2zz1kbd64v1+h/s2r+oJsnqSrJ5bu/a9b+3ad7JJpE42idTJJpH6kJEtw+Xad7JJpD5crn0fsu58yLTzIdPOh0s7j4NLPYmDSz2Jg0s9iePWrqM4/N7lc2nncXBp53FwkS1xcJEtcXC5jkK4XEchXK6jELK7v3Bp5wE3kV7Vw6Wdh3B15yFc3XmQzQoNubXrKPTWrqNQLm0mlEubCeUiWwLuOb2qh8t1FMrlOgrlch0Fmec0lEybMTJtxsi0GSPrzo2sO4e7Qq/qubXrKOzWrqMwMm3GyLQZ43pzGs715jScy3UUzuU6CudyHQWZ5zScTJtxMm3GybQZJ+vOnaw7D7LuPLjydCO48nQjuPJ0A+4KvaqHK0834mfm6b7nYiOKrB44d/4p9xlwV+hFPXBX6FU9QlbPrW2ekfcGYchcoUHmCg0yV2gkmXqCd4V+/muczBUaRUa2kLlCg8wVGmSu0CBzhQaZKzTIXKFRZOrJvYd/Rt0bhCGbFRpks0KDbFZoNBnZgp8V+nl3RTYrNJqMbCGbFRpks0KDbFZokM0KDbJZoUE2KzSGrDuHu0Kf257MvUGYIdNmhkybGTKyZbjIlsR7Tj/trvLgch3lwUW25MF198/Dyerh0mby4NJm8uDqzvPg6s7z4OrOU25tI0q5dfxuCpc2k8KlzSTcc3pVD9eb08R7Tj/vroTLdZTClaebQnb3Vy5tJpVLm0mySaRJNok0ySaRJtkk0tSfyTW+5yxTufJ0U7nydFO58nTTuPJ007jydNO48nTTuPJ0E+4KvaqHK083jStPN+3WebpptwZhkswVmmSu0HQusiWdTD1xrjzdxLtCP//161xkS5K5QpPMFZpkrtAkc4UmmSs0g0w9CTL1JG5tI0q4ifTJ5ZNp58FFtmRwkS0ZXGRLBleebiaX6yiTjGxJsrt/kmnncFfoVT1k2nmSdedJ1p0nWXeet7YRZd0bhCkybabItJkiI1vgntOrerjydLO4XEdZZGRLkd39i0ybaTJtpsm0mSbrzpusO8e7Qi/qubWNKPvWebrZZNpMk2kzZJNIk2wSaQ5Xnm4OmetouPJ0c8ju/kOmzZBNIk2ySaRJNok0ySaRFtkk0jq48nTr4MrTrYMrT7cOJ6uHK0+3Dq483Tq48nTr4MrTrYMrT7eEK0+3hCtPt+TWeboltwZhiswVWmSu0BIusqWESz0p4crTLeHK0y3lIluKzBVaZK7QInOFFpkrtMhcoaVc6kkpl3pSemsbUemtQZgyLu28jItsKeMiW8q4yJbCTyL9vLsyLtdRGRfZUkZ29zcu7byMTDt3Mu3cybpzJ+vOnaw7h7tCn9ue+K1BmHIybcbJtBnnIlvKuciWCq483Qou11EFF9lSQXb3h5tIr+oh02aCTJsJsu48yLrzIOvO89Y2ospb5+lWkmkzSabNkE0iLbJJpJVcebqVXK6jSq483Uqyu3+RaTNkk0iLbBJpkU0iLbJJpEU2ibSKK0+3iitPt4orT7eKK0+3mitPt5orT7eaK0+3mitPt+Cu0Kt6uPJ0q7nydKtvnadbfW8QhswVWmSu0BoysmXI1JPhytMtvCv081+/Q0a2kLlCi8wVWmSu0CJzhTaZK7QPLvWkDy71pI9b24j68HuXz6Wd98FFtvTBRbb0wUW29MGVp9vC5Tpq4SJbWsju/sKlnTfcFXpVD5d23sLVnbdwdectXN15y61tRK23BmFaubSZVi5tppWLbGm45/SqHq483VYu11ErF9nSSnb3VzJtxsi0GSPTZoysOzey7hzvCr2o59Y2orZb5+m2kWkzRqbNkE0ibbJJpO1cebrtXK6jdq483Xayu7+TaTNkk0ibbBJpk00ibbJJpE02ibSDK0+3gytPt4MrT7fhrtCrerjydDu48nQ7uPJ0O7jydDu48nQ7ufJ0O7nydDtvnafbeW8QhswV2mSu0E4ysiXJ1JPkytPt5MrT7SIjW8hcoU3mCm0yV2iTuUKbzBXaRaaeFJl6Ure2EXXdG4RpMu28yciWJiNbmoxswU8i/by7ai7XUTcZ2dJkd/8m086bTDsfMu18yLrzIevOh6w7h7tCn9uezL1BmCHTZoZMmxkysmW4yJY5uPJ05+ByHc3BRbbMwXX3n8PJ6uHSZubg0mbm4OrO5+Dqzufg6s5Hbm0jGrl1nu4IlzYzwqXNDNkk0iGbRDrClac7wuU6GuHK0x0hu/srlzYzZJNIh2wS6ZBNIh2ySaRDNol0lCtPd5QrT3eUK093lCtPd4wrT3eMK093jCtPd4wrT3fgrtCrerjydMe48nTHbp2nO3ZrEGbIXKFD5god5yJbxsnUE+fK0x28K/TzX7/ORbYMmSt0yFyhQ+YKHTJX6JC5QifI1JMgU0/i1jaigZtIn1w+mXYeXGTLBBfZMsFFtkxw5elOcrmOJsnIliS7+yeZdg53hV7VQ6adJ1l3nmTdeZJ153lrG9HUvUGYItNmikybKTKyBe45vaqHK093ist1NEVGthTZ3b/ItJkm02aaTJtpsu68ybpzvCv0op5b24imb52nO02mzTSZNkM2iXTIJpHOcOXpzpC5joYrT3eG7O4/ZNoM2STSIZtEOmSTSIdrEmkdXJNIz3qo8nTPeqjydM96qPJ0z3qcrB6qPN2zHqo83bMeqjzdsx6qPN2zHqo83TqEKk/3rIcqT/es5855umf5dwZhzvKd6dfdWQ8V2XLWQ0W2nPVQqSdnPVR5umc9VHm6dSgV2XLWQ6Wdn/VQaednPVTa+VmPk9VDpZ6c9VCpJ2c9VOrJWc+dbURn+XcGYeowKu38rIeKbDnroSJbznqoyJazHufqrozKdXTWQ0W2nPWQ3f2NSjs/6yHTzp1MO3ey7tzJunMn687hrtDntid+ZxDmLJ9Mm3EybcapyJazHiqypY6gytM966FyHZ31UJEtZz1kd3+4ifSqHjJtJsi0mSDrzoOsOw+y7jzvbCM6y79znu5ZPpk2k2TaDNck0rMesjenSZWne9ZD5To666HK0z3rIbv7F5k2wzWJ9KyHTJvhmkR61kPWnXNNIj3rocrTPeuhytM966HK0z3rocrTraOp8nTPeqjydM96qPJ0z3qo8nTPepysHqo83bMeqjzds5475+me5d8bhOFyhdbB5Qo96yEjW4ZMPRmqPN2zHuf69TtkZAuXK/Ssh0w753KFnvVwqSdC5gqVg0s9kYNLPZHj1jYiOfze5XNp53JwkS1ycJEtcnCRLXJQ5emWCJfrSISLbBEhu/sLl3YucFfoVT1c2rkIV3cuwtWdi3B15yK3thGJ3hqEEeXSZkS5tBlRLrJF4J7Tq3qo8nTPerhcR6JcZIso2d1fybQZI9NmjEybMbLu3Mi6c7wr9KKeW9uIxO6cp3uWT6bNGJk2wzWJtIRrEulZD1We7lkPl+tInCpP96yH7O7vZNoM1yTSsx4ybYZrEulZD1l3zjWJ9KyHK09XgitPV4IrT1fgrtCrerjydCW48nQluPJ0JbjydCW48nQlufJ0JbnydCVvnacreW8QhswVKmSuUEkysiXJ1JPkytOV5MrTlSIjW8hcoULmChUyV6iQuUKFzBUqRaaeFJl6Ure2EUndG4RpMu28yciWJiNbmoxswU8i/by7ai7XkTQZ2dJkd/8m086bTDsfMu18yLrzIevOh6w7h7tCn9uezL1BmCHTZoZMmxkysmW4yBY9uPJ09eByHenBRbbowXX318PJ6uHSZvTg0mb04OrO9eDqzvXg6s5Vbm0jUrl1nq4KlzajwqXNKNkkUiWbRKrClaerwuU6UuHK01Uhu/srlzajZJNIlWwSqZJNIlWySaRKNolUlStPV5UrT1eVK09XlStPV40rT1eNK09XjStPV40rT1fhrtCrerjydNW48nTVbp2nq3ZrEEbJXKFK5gpV5yJb1MnUE+fK01W8K/TzX7/ORbYomStUyVyhSuYKVTJXqJK5QjXI1JMgU0/i1jYihZtIn1w+mXYeXGSLBhfZosFFtmhw5elqcrmONMnIliS7+yeZdg53hV7VQ6adJ1l3nmTdeZJ153lrG5HWvUGYItNmikybKTKyBe45vaqHK09Xi8t1pEVGthTZ3b/ItJkm02aaTJtpsu68ybpzvCv0op5b24i0b52nq02mzTSZNkM2iVTJJpHqcOXp6pC5joYrT1eH7O4/ZNoM2SRSJZtEqmSTSJVsEqmRTSK1gytP1w6uPF07uPJ07XCyerjydO3gytO1gytP1w6uPF07uPJ0TbjydE248nRNbp2na3JrEMbIXKFG5go14SJbTLjUExOuPF0TrjxdUy6yxchcoUbmCjUyV6iRuUKNzBVqyqWemHKpJ6a3thGZ3hqEMePSzs24yBYzLrLFjItsMfwk0s+7K+NyHZlxkS1mZHd/49LOzci0cyfTzp2sO3ey7tzJunO4K/S57YnfGoQxJ9NmnEybcS6yxZyLbLHgytO14HIdWXCRLRZkd3+4ifSqHjJtJsi0mSDrzoOsOw+y7jxvbSOyvHWeriWZNpNk2gzZJFIjm0RqyZWna8nlOrLkytO1JLv7F5k2QzaJ1MgmkRrZJFIjm0RqZJNIrbjydK248nStuPJ0rbjydK258nStufJ0rbnydK258nQN7gq9qocrT9eaK0/X+tZ5utb3BmHIXKFG5gq1ISNbhkw9Ga48XcO7Qj//9TtkZAuZK9TIXKFG5go1Mleok7lC/eBST/zgUk/8uLWNyA+/d/lc2rkfXGSLH1xkix9cZIsfXHm6LlyuIxcussWF7O4vXNq5w12hV/VwaecuXN25C1d37sLVnbvc2kbkemsQxpVLm3Hl0mZcucgWh3tOr+rhytN15XIduXKRLa5kd38l02aMTJsxMm3GyLpzI+vO8a7Qi3pubSNyu3WerhuZNmNk2gzZJFInm0TqzpWn687lOnLnytN1J7v7O5k2QzaJ1MkmkTrZJFInm0TqZJNIPbjydD248nQ9uPJ0He4K/Zz79Aiyesjuz2SuUH+CK9T0+PabwdTe/2R4gtHzaokneDcvl5D9S+j+JWz/Ev6EJSLeluj3TfsTzIeXS+T+JWr/Er1/idm+RB37l5D9S+j+JWz/Evt39zOsayHfftWei72/Rz3DjXa1RO1fovcvMduXeIaz62oJ2b+E7l/C9i/h+5fYv7t7/+7u/bu79+/u3r+7Z//unv27e/bv7mdYZqLkbYn5YAnfv0TsXyL3LwH/kf75S4q5tZvQ59Y8XBxcr9Di4ALc4uAC3OLgAtzicKq7SRxc5sM4uAC3OG5tPY/j1g+LOLgAihCyu7+Q3f2F7O4vXNbzwJtbPr+7Cdndn8zcEmTmliAzt4RwARShXABF6K1zWENvPR8zyMwtQWZuCeWynodyWc9DuZSfUK7Y1lCugZdBZm4JMnNLkJlbgszcEmTmljAuvDmMrDs3rnH0YU1Wz3DV4wdZPffuzv3e3bmTdedwc8tVPWTdOdnIs3Cy7tzJunMn687JzC0RZN15kHXnZCPPgmzkWZCNPAsyc0vEvd+cxr3fnAbZm9Mke3OaZG9OyUaeRZK9OYWPPLvoZpLszWmS3f2T7M1pkr05JRt5FmQjz4Js5FmQjTyLunVod8AnpD25fDJtpsi0meIKhoriCoaK4grtjuYK7Y7mCu2OJrv7N5k2Ax+odlUPmTbTZN15k3XnTdad971NSnPr0O4gG6gWZAPVYsjenMIHql3VwxXaHUPmaRqu0O4gG6gWZAPVkmygWpINVEuygWp5cHXneXB153n8zFjA97GJeXCNo8+Daxx9Hlzj6PPgGkefwjWOPoUrtjWFK7Y1hSu2NeGu0Kt6yO7PQnZ/FrL7s5Ddn4Xs/qxk92cluz8r2f1Zf+b9+b1PINXJ6rn10JvUWw+9SeV6t5nK9W4zlYs8TOMiD9O4ht6kcQ29SeMaepNkrtAkc4UmmSs0jevdZhqXup1Gpm47mbp9b1do3tsVmmSu0CRzhSaZKzTJXKFJ5gpNMldokrlCk8wVmmSu0CRzhSaZKzTJXKFJ5gpNMldo3tsVmvd2hSaZKzTJXKFJ5gpNMldokrlCk8wVmmSu0CRzhSaZKzTJXKFJ5gpNMldokrlCk8wVmvd2hea9XaFJ5gpNMldokrlCk8wVmmSu0CRzhSaZKzTJXKFJ5gpNMldokrlCk8wVmmSu0CRzhWaTcY1DxjUOGdc4ZFzjkHGNcN/mVT1w7jze+jGP9/sd7tu8qqfI6mmyem7t2q/j1q79IptEWmSTSItsEmkdTlYPl2u/yCaR1sHl2q+Dqzuvg0s7L+HSzku4tPMSLvWkhEs9Kfys0It6bu06Krm166iESzsv4dLOS7jIllIusqWUy3VUyuU6KuVyHZWS3f2VSzsv5dLOS7m081Ky7lzJunOyWaFlt3Ydld3adVRGps3APadX9XCRLWVcZEsZl+uojMt1VMblOioyz2k5mTbjZNqMk2kzcFfoVT1k3bmTded+a9dR+a1dR+Vk2kyQaTNB9uY0yN6cBpfrqPCe08+7meByHRWZ57SCTJsJMm0myLSZJOvOk6w7T7LuPLnydAvuCr2qhytPt5IrT7eSK0+38mfm6b7nYiuHqx64K/Rz7rPgrtCrepSsHiOrx2/9c7buDcKQuUKLzBVaZK7QKjL1BO8K/fzXOJkrtJqMbCFzhRaZK7TIXKFF5gotMldokblCq8nUk3sP/6y5NwhDNiu0yGaFFtms0BoysgU/K/Tz7opsVmgNGdlCNiu0yWaFNtms0CabFdpks0L74OrO++Dqzvu4tY2oj1uDMH1waTN9cGkzLVxkSwsX2dJ4z+mn3VULl+uo8Z7Ti3rI7v7Cpc20cGkzLVzaTAtZd65k3bmSded6axtR663jdxvuOb14WiuXNtPK9ea0ySaRNt5z+nl3pVyuozauPN02sru/kWkzRqbNkE0ibbJJpE02ibTJJpG2/UyuUT64/3Dl6bZz5em2c+XptnPl6bZz5ek23BV6VQ9Xnm47V55uO1eebjtXnm77rfN0O24NwjSZK7TJXKEdXGRLw12hV/Vw5el2cOXpdnCRLU3mCm0yV2iTuUKbzBXaZK7QTjL1BD8r9KKeW9uIOu8NwiSZdp5kZEuSkS1FRrYUV55uF5frqIuMbCmyu3+RaedFpp0XmXZeZN15kXXnTdad961tRN33BmGaTJuBe06v6iEjW5qMbGmuPN1uLtdRNxnZMmR3/yHTZoZMmxkybQbuCr2qh6w7H7LufO5tI5pb5+n2cGkzc3BpM0M2iXTIJpHOwZWnO4dTdTNzcOXpzsF195+DS5sZskmkQzaJdMgmkQ7ZJNIhm0Q6wpWnO3BX6FU9XHm6I1x5uiNcebojXHm6I1x5uqNcebqjXHm6o1x5uqNceboD920+9efs6K1BmCFzhQ6ZK3SUi2wZJVNPjCtPd4wrT3eMi2wZMlfokLlCh8wVOmSu0CFzhY6RqSdGpp74rW1E47cGYcbJtHPnIlsG7jm9qoeLbBnnytMd53IdjXORLeNkd/8g086DTDsPMu08yLpz/KzQi3rIuvO4tY1o4tYgzASZNhNk2kySkS1JRrYkV57uJJfraPCe04t6yO7+SabNJJk2k2TaTJJ150XWnRdZd163thFN3TpPd+Ce04undZFpM2STSIdsEukUV57uFJfraJorT3ea7O7fZNoM2STSIZtEOmSTSIdsEumQTSKd5srTnebK053hytOd4crTneHK053hytMduCv0qh6uPN0ZrjzdGa483RmuPN2ZO+fp9nHcGYQ5y6fSzs96qMiWsx4qsuWsx8nqocrTPeuhytM966EiW856qLTzsx4q7bwPLlfoWQ+VenLWQ6WenPVQqSdnPU5Wz51tRGf5dwZhzvKptPOzHiqy5ayHimzpQ6nIlrMeqjzdsx4q19FZDxXZctZDdvdXKu38rIdKOz/rodLOz3rIunMl686NrDu3O9uIzvLvDMKc5ZNpM3DP6VU9VGTLWQ8V2XLWQ5Wne9ZD5To666EiW/pwsru/k2kzTqbNOJk2A3eFXtVD1p07WXfud7YRneXfOU/3LJ9MmwkybYZrEulZD9mb06DK0z3rca5uJqjydM96yO7+QabNcE0iPesh02a4JpGe9ZB151yTSM96qPJ0z3qcrB6qPN2zHqo83bMeqjzdsx6qPN2zHqo83T6KKk/3rIcqT/eshypP96yHKk/3rMdv/XO27g3CcLlCz3rIyJYiI1uKTD1pqjzdsx6qPN2zHjKyhcsVetbjZPWQaedcrtCzHjL1pMnUkyZTT+beNqK5NwgzZNr5kJEtcM/pVT1kZMtQ5eme9ZC5joaMbBmuu78cXNq5HFzauRxc2rkcXN25HFzduRxc3bkct7YRyXFrEEYOLm1GDi5tRoSLbBHhIltEqPJ0z3q4XEeC95xe1EN29xcubUaES5sR4dJmRMi6cyXrzpWsO9db24hE75yne5bvXE9r5dJmhGsS6VkP15tTUao83bMeLteRGFWe7lkP2d3fyLQZrkmkZz1OVg9Zd841ifSsh6w7N6o83bMeqjzdFqfK0z3rocrTPeuhytM966HK0z3rcbJ6qPJ0z3qo8nTPeqjydM96qPJ0z3punacrcWsQRshcoULmCpXgIlsE7gq9qocrT1eCK09XgotsETJXqJC5QoXMFSpkrlAhc4VKkqkn+FmhF/Xc2kYkeW8QJsm08yQjW5KMbCkysqW48nSluFxHUmRkS5Hd/YtMOy8y7bzItPMi686LrDtvsu68b20jkr43CNNk2gzcc3pVDxnZ0mRkS3Pl6UpzuY6kyciWIbv7D5k2M2TazJBpM3BX6FU9ZN35kHXnc28b0dw6T1eGS5vRg0ubUbJJpEo2iVQPrjxdPZyqm9GDK09XD667vx5c2oySTSJVskmkSjaJVMkmkSrZJFIVrjxdhbtCr+rhytNV4crTVeHK01XhytNV4crTVeXK01XlytNV5crTVeXK01W4b/OpP2dVbw3CKJkrVMlcoapcZIsqmXpiXHm6alx5umpcZIuSuUKVzBWqZK5QJXOFKpkrVI1MPTEy9cRvbSNSvzUIo06mnTsX2aJwz+lVPVxkizpXnq46l+tInYtsUSe7+weZdh5k2nmQaedB1p3jZ4Ve1EPWncetbUQatwZhNMi0mSDTZpKMbEkysiW58nQ1uVxHivecXtRDdvdPMm0mybSZJNNmkqw7L7LuvMi687q1jUjr1nm6CvecXjyti0ybIZtEqmSTSLW48nS1uFxH2lx5utpkd/8m02bIJpEq2SRSJZtEqmSTSJVsEqk2V56uNleerg5Xnq4OV56uDleerg5Xnq7CXaFX9XDl6epw5enqcOXp6nDl6ercOk/XjluDMEbmCjUyV6gdXGSLHU5WD1eerh1cebp2cJEtRuYKNTJXqJG5Qo3MFWpkrlATLvXE8LNCL+q5tY3I5NYgjAmXdm7CRbaYcJEtplxkiylXnq4pl+vIlItsMSW7+yuXdm7KpZ2bcmnnpmTduZJ150bWndutbURmtwZhzMi0Gbjn9KoeLrLFjItsMePK0zXjch2ZcZEt5mR3fyfTZpxMm3EybQbuCr2qh6w7d7Lu3G9tIzK/dZ6uOZk2E2TaDNkkUiObRGrBladreM/p591McOXpWpDd/YNMmyGbRGpkk0iNbBKpkU0iNbJJpJZceboGd4Ve1cOVp2vJladryZWna8mVp2vJladrxZWna8WVp2vFladrxZWna3Df5nN/zta9QRgyV6iRuUKtyMiWIlNPmitP15orT9eajGwhc4UamSvUyFyhRuYKNTJXqDWZetJk6snc20Y09wZhhkw7HzKyBe45vaqHjGwZrjxdGzLX0ZCRLcN19/eDSzv3g0s794NLO/eDqzv3g6s794OrO/fj1jYiP24NwvjBpc34waXNuHCRLS5cZIsLV56uC5fryPGe04t6yO7+wqXNuHBpMy5c2owLWXeuZN25knXnemsbkeut83Qd7jm9eForlzbjZJNInWwSqStXnq4rl+vIjStP143s7m9k2gzZJFInm0TqZJNInWwSqZNNInXjytN148rTdefK03XnytN158rTdefK03W4K/SqHq48XXeuPF13rjxdd648Xfdb5+l63BqEcTJXqJO5Qj24yBaHu0Kv6uHK0/XgytP14CJbnMwV6mSuUCdzhTqZK9TJXKGeZOoJflboRT23thF53huESTLtPMnIliQjW4qMbCmuPF0vLteRFxnZUmR3/yLTzotMOy8y7bzIuvMi686brDvvW9uIvO8NwjSZNgP3nF7VQ0a2NBnZ0lx5ut5criNvMrJlyO7+Q6bNDJk2M2TaDNwVelUPWXc+ZN353NtGNLfO0/Xh0mbi4NJmgmwSaZBNIo2DK083DqfqZuLgytONg+vuHweXNhNkk0iDbBJpkE0iDbJJpEE2iTSEK0834K7Qq3q48nRDuPJ0Q7jydEO48nRDuPJ0Q7nydEO58nRDufJ0Q7nydAPu23zqz9nQW4MwQeYKDTJXaCgX2RJKpp4YV55uGFeebhgX2RJkrtAgc4UGmSs0yFyhQeYKDSNTT4xMPfFb24jCbw3ChJNp585FtgTcc3pVDxfZEs6VpxvO5ToK5yJbwsnu/kGmnQeZdh5k2nmQdef4WaEX9ZB153FrG1HErUGYCDJtJsi0mSQjW5KMbEmuPN1ILtdR4D2nF/WQ3f2TTJtJMm0mybSZJOvOi6w7L7LuvG5tI4q6dZ5uwD2nF0/rItNmyCaRBtkk0iiuPN0oLtdRNFeebjTZ3b/JtBmySaRBNok0yCaRBtkk0iCbRBrNlacbzZWnG8OVpxvDlacbw5WnG8OVpxtwV+hVPVx5ujFceboxXHm6MVx5ujG3ztPN49YgTJK5QpPMFZoHF9mSh5PVw5WnmwdXnm4eXGRLkrlCk8wVmmSu0CRzhSaZKzSFSz1J/KzQi3pubSNKuTUIk8KlnadwkS0pXGRLKhfZksqVp5vK5TpK5SJbUsnu/sqlnadyaeepXNp5Kll3rmTduZF153ZrG1HarUGYNDJtBu45vaqHi2xJ4yJb0rjydNO4XEdpXGRLOtnd38m0GSfTZpxMm4G7Qq/qIevOnaw791vbiNJvnaebTqbNBJk2QzaJNMkmkWZw5ekm3nP6eTcTXHm6GWR3/yDTZsgmkSbZJNIkm0SaZJNIk2wSaSZXnm7CXaFX9XDl6Wb+zDzd99xnZpHVQ3Z/JnOF5hNcoabHt98Mpvb+J8MTjJ6XS+j+JWz/Er5/idi/RD5hiYi3Jfp90/4E8+HlEr1/idm+RB/7l5D9S+j+JWz/Er5/idi/xP7d/QTrmlt/+9V//qO+X6L3L/H3727Pt2e3t8bnD3qRmTfpTg99X9ETLGbPrkjoKlK6igxckR4e3yuK9/vzCVaz5YrsdxX153/ulfr235a++m+71tt/2+O9YPkEI9udzjZf6mzrpc62f6mzlfz8bOeFzraO45c62989E0M+OFt5qbPVlzpbe6mz9V/qbN/e/f52tnL159LfL84pKl38eRz17U3l+c8t76/lr9Wp/dxr+Wv1gT/3Wv5aXebWa3n+Hn67lmIf3C9/rR72517LX6tD/qnXUn6t/nvvtfyuL4Xk+/ul/Frd/c+9lr/Wb4efey1/rV8mP/da+te1fNq1/Prd87xr+fW753nX8ut3z99+Lfv7b0iZD67l1++e513Lr989T7uW+vW753nX8ut3z998LfV4ex8Wqvb+Wn797nnetfz63fO8a+lf1/Jp1/Lrd8/zruXX757nXcuv3z1/+7V0/X4t44Nr+fW753nX8ut3z9OupX397nnetfz63fO3X8vs79ey4/21/Prd87xr+fW753nX0r+u5dOu5dfvnuddy6/fPc+7ll+/e553Lb9+9zzt97h9/e552rX0r989f/O1vHo/7l+/e553LX/C755PXbLlbL7dekLQ6Z2/b/L9+yZ/bwxm+Wv34M+9lq/dgz/3Wr52D/7ca/naPfjStQx5Y1s89INnz2v34E+9lvHaPfhzr+Vr9+Br1/L7RfHoeX8tX/vdw3Ov5Wu/e3jutfSva/m0++XX756n9ZeRbApBFF1Fv1QPHqbfv291XPy5hb9tRovK9xfnl2qqn3xx8pfqkhcvTh7fL06Kvr84v1Tb++yL80v1sc++OL9UY/rsi+OvfENu/d3FsavuyL73Xm4fvAHPX6rT/MnX8pdS2H/ytfylFPa919LVvv8C+v1V+XYtX7q7f/K1fOkfA8+9lvXKvx1Wr2V/v1/6vL9f1iv/1Hj2tXzlXybPvpav/EPm2dfSv67l33otw/O7wv6B4llfv3uedy2/fvc871p+/e552rXsX+s5Xt9nE8T0+7P9tZ60V2eLfxZqfz9bf59N+4SpYGcDkG8V5Xvh8wlTwS6XeML9Z/rb28Y4PpBvnzEV7GqJ2b7EM8Z8XS3x9/+mi+NtWk0c8R7aeMIgrsslbP8Svn+J2L9E7l+i9i/R+5eY3Uv0Ewb9XC4h+5fQ/UvY/iV8/xKxf4ncv0TtX6L3L7F/d8v+3S37d7fs392yf3fL/t0t+3f3EwKtQ4+3JTQ/WKL2L9H7l5jtSzwhLPdyCdm/hO5fwvYv4fuXiP1L7N/dun936/7drft3t+3f3bZ/d9v+3W37d/cT4qbC5BvtH/Yf+eIPRLj6XaBLmV7kGczoN31lxvt9+XHv8vPe5de9y2/y8udNQD8O+WDvzr3rf0JEzs+tX25ev1LXfxb9/X3NcdgHJ2B3PwHup+/fcALcz9+z6LdXluc/1wcnwP0E/htOgPsZLIccb6+YDxF7fwLcT+G/4QS4H8PXJxDcz+Gz6KjvJ5D1/gS4H8R/wwmwP4kvT4D9SXx5AuwPMs03S/35UPb3J8D+ILs8AfYH2X84gfdTyTrYH2SXJ8D+ILs6gWR/kF2eAPuD7PIE2B9klyfA/iC7PAG/+wnc6kn80Qnc6kn80Qnc/Umcd38S592fxHX3J3Hd/Ulcd38S192fxE/w+iFP4P1v4mJ/Ett3d/phH6jTxf4kvjwB9iex21vOz+H+wVeI/Ul8eQLsT+KrE2j2J/HlCbA/iS9PgP1JfHkC7E9i/17J4XO8PwH2J/HlJ8D+JL48AfYn8eUJ3P1J3PRP4qtNfPcn8dz9STx3fxLP3Z/Ec/cn8TNsvj/3E7j7k3ju/iSeuz+J5+5P4rn5k3iOmz+J57j5k3iOmz+J57j5k3iOmz+J57j5k3iOmz+J57j5k3iOmz+J57j7k1ju/iSWuz+J5e5PYrn7k/gZ8Rk/9xO4+5NY7v4klrs/ieXuT2K5+5NY7/4k1rs/ifXuT2K9+5P4GVE3P/cTuPuTWO/+JNa7P4n17k9ivfuT2O7+JLa7P4nt7k9iu/uTmDyW6m/4BO7+JCaPpvobTuDuT2LyeKq/YRPf/UlMHlD1N5zA3Z/E9BFVlydw9ycxfUTV5Sdw9ycxfUTV5Qnc/UlMH1F1uYnhT2Kbt7yd8v84pOiDP5fzgG9/LvLeijj4iKpnn4CQn4Ad8XYCpvn+BPTuJ2B3PwG/+wkE+Ql4vT0HJI6ru67Od/+0zlz910P87fKEpLy/PPl1eT67PPV1eT67PP11eT67POwd0M+9PMneX/3ky8Pevf3ky8PeG+69PHq85ayHqr2/POyd50++PP51eT67PK/dNV9entfumi8vz2t3zZeX57W75t/JjKEd7y/Pa3fNV5enXrtrvrw8r901X16eF++ary7Pi3fNV5fH2S+PzNvlcZ33J0Df116dAH3neXUC9L3h1Qn8at2b/u4W4f7+fH+1duzifPtX66+uzvdXa5iuzvdX64CO/vx8f7WW5up8/cXO91eT6q7O91fT3mp+16K/f8/Rv5qYdnW+v1p/dXW+v1p/dXG+89r61fH9vx5Hf3B5Xlu/urw8r61fXV6e19av5Ptv9xB7jyTjk2DvdXlenJW8ujwvzkpeXZ4XZyX7+61ZPup7XpyVvLo8L85Kfnp55jhenJW8ujwv/tbX384zNOz95Xnxt75Xl+fF3/peXR7/ujyfXZ4XZyU/ZQbOy/PFSr5dHv3g2/PFSn56eb4cRm99T37Q93w5jD67PHJvB/d5Aux97eUJ/Fqdpx35dr+yo4/35/trtZLX5+svdr6/VrN3fb7s3Vv4d1wv8n37Kez91eUJsHdAlyfA3qNcnYCydxHWb5WIH1d/7v79fN0/Ol/62Jgnny99ysyTz5c+lObJ5+u3Rs7PE7i3a+E8gXu7Fs4TuLdr4TyBl3ItnOf7Uq6FOeylXAvn+b6Ua+E831/tDd7V+f5qr+SuztdfieI/z/elXAvn+f5qb8GuzvdXe611db4v5Vo4z/elXAtz+K/WX12d76/WX12d75ev4C9//oGv4Lw8r01IXV4e/7o8n12eL1/Bt8vzHpw/L8+Xr+DTy/PivoKry/PihNTV5fnyFbxdng/6HvoZFz/58rx4BvPV5Xntrvny8nz5Cr5dno/AefrZIj/58ry4r+Dq8ry4r+Dq8ry4r+DClfLik0uubBcvPrnk6vJ8TS753vd8YLv4mlzy+eVh75qvTB30s0UuT8Bfi+L/xcZ5XJ/vr9UbXp/vr9XsXZ8vffcWv7MUSL4/Afr+6uIE+KdQXJ0AfY9ydQL02tvVCdCrY1cn4Dc3NtFPQ7g8gbu7E+mnIVyeAPuT+MleIvppCE8+X/ppCM8+3xfzPtJPQ3j2+dI3HRdGLv7xBlcncHczI/8AgqsT+NVeDV14a365iQJX5/ti3sdfbqLA1fm+mPfxl8v8vzrfl5rYdJ6vv9j5vpj38ZfLzb8635ea2HSe74t5H3+5qPrPz1d+uez5q/P9GsH0lz//yM0lLx4mf3l5vqySn14e/7Ir/eXyfGBXkhcPk7+8PF9WyU8vz5dV8tPL8zWC6e3yfNT3fFklP7s89GHyP/nyfFklP708XyOYvl2eD+xK8ovl5j/98vjX5fns8nxZJT+9PC9ulfzcCyj0IwJ+qtlN6AcQ/OTL8zWC6a3veW92E/rhCT/58tx8wJPQD0+4PIHXmtgk/NMQnny+r+V9FP5ZC08+X/ru7XMbkfCPZrg6gZubGYV/eMLVCdzczCj84w2uToC9i7gwcgn9AILLE7i5mVHoRwRcngD7k/i5XiKhz/x/9vm+lvdR6DP/n32+r+V9FP7M/8+NXMKfyn91An73E7i5mVF+uez5z7018suFyV+d72t5H+WXi3u/ON9fLr/9c2+N/HKB7Ffn+6thQ1fn+1reR/nlMtAvvDW/XKj51fn+av3V1fm+lvdRXjxH/Mrt8+I54leX58VzxC8vz4sj5Rd2Fvoc8Z98eV4bKb+8PP51eT67PC9uxLyws/xiCetPvzwvbsS8ujxfRsxPL8+LT9+5sLPwZ8//3Mvz2l3z5eX5MmJ+enle3Ih54RWjz/z/uWYo+okCP/nyvHjXfGGGop+G8JMvD3vXfGW1oh+ecHUC9NMQnuytoZ+G8Ozz/bV6w+vzfTHvI//whAubCf/whKsToO+Ark7g7nZD/mkIVydwd7sh/byCPL6fQLq+PwH2tuDyBNif8zn+dgIl7x9k9CMCLk+A/Ul8eQLsT+LLE2B/Etfv7IaVH2xi9idxWXx+AuxP4suvEPuT+OIElD7Z/vIE6J/EVyfA/iS+uAspfdz7xV1Ij5s/iZU+Mv3yBNifxJcnwP4kvjwB9ifx5V2I/Ul8dReiD9e++grRx19fnsDNfxMrfYT05QmwP4mv7kL0McyXd6G7P4npo4wvT+Dmv4mVPg746gToA3uv7kL0kbpXdyH6SN3Lr9Ddn8T0GbmXJ3D338T0KbaXd6Gbq9NKH0t7+RW6+5OYPpb28gTu/puYPpb26i5EH0t7dReij6W9/Ard/UlMH0t7eQJ3/01MnzN7eRe6uzpNnwR79RWij3a9PIG7/yamz2q9PAH2J/HVXYg+q/XyLnT3JzF9+OrlCdz9NzF9POrVCdDnnV7dhegDTK/uQvSJpJdfobs/iekzQy9P4O6/ielTPS/vQndXp+lzNy+/Qnd/EtNnV16ewN1/E9PnP17dhegTGq/uQvQZipdfobs/ielzCC9P4O6/iemz/C7vQndXp+nz8K6+QvSJdZcncPffxPSpb5cnwP4kvroL0SenXd6F4E/i/J7WVHXY+4qKriL4s7LsdxXVB5/asFWEz9iq7/eWaqn3FQldRfDnTf/uU+uI9xU94wHS326R4XKV9dQib9eoJd4/EZ6S9fTcioKuoqSrqOgqarqKhq2ipyQaPbcioatI0RWpv92z+2yQP//znOPb8yDnd48c6Q/++PxPfzvZ1t/1gucf/59ztRc6V3+hc40XOtd8oXOtFzrXfqFznZc5VzuOFzpXeaFzfZ2+yY7X6Zvs8Bc619fpm+x4nb7Jjtfpm+x4nb7Jjhfqm+SF+iZ5ob5JXqhvkhfqm56SEnaXc32hvkleqG+SF+qb5IX6JnmhvklfqG/SF+qb9IX6Jn2hvukpmW53OdcX6pv0hfomfaG+SV+ob9IX6pvshfome6G+yV6ob7IX6pueksB3l3N9ob7JXqhvshfqm+yF+iZ7ob7pBxmE428Tsuf3No6PznXi23js6X77U52/LPBxszLzbQE9jv79Av/nKH3oKHvoKH/oqHjoqHzoqHroqH7oqHnkqB8EaF0d9dB3Ix76bsRD34146LsRD3034qHvRjz03YiHvhvx0HcjH/pu5EPfjXzou5EPfTfyoe9GPvTdyIe+G/nQdyMf+m7kQ9+Neui7UQ99N+qh78bHHnY91N6Osg+O8o+PCn07Kv39UfHxUdXfjpLjeH/Uh98N/e4cUjF7f1R9fJTX21H1wVr90FHzyFEfW3Yvj5KPj+q3q6HH+yv/sfX18ih76Ch/6KiPvxvnYW9HWb0/6uPvhoa8HZXx/qiPvxta83bUfHDUx98NO96OOpXm90fN6lHnv/yXf/3Tn//8p//2n//8L//4D//+p3/553/77dDjt//zA4H3sx71Bzrpp4d8LDd+foisH6Lrh9j6Ib5+SKwfkuuH1Poh65++rX/6vv7p+/qn7+ufvq9/+r7+6fv6p+/rn76vf/q+/un7+qcf659+rH/6sf7px/qnH+uffqx/+rH+6cf6px/rn36sf/q5/unn+qef659+rn/6uf7p5/qnn+uffq5/+rn+6ef6p1/rn36tf/q1/unX+qdf659+rX/6tf7p1/qnX+uffq1/+r3+6ff6p9/rn36vf/q9/un3+qff659+r3/6vf7p9/qnP+uf/qx/+rP+6c/6pz/rn/6sf/qz/unP+qc/65/+LH/6fhzrh8j6Ibp+iK0f4uuHxPohuX5IrR/S64esf/qy/unL+qf/sbmq5Zto2B7vDrH1Q3z9kFg/JNcOOf9FfvtDWf9yyvqXU9a/nLL+5ZT1L6esfzll/csp619OEV0/xNYPWf/0Zf3Tl/VPX9Y/fVn/9GX909f1T1/XP31d//R1/dPX9U9f1z99Xf/0df3TXxeiZV2IlnUhWtaFaFkXomVdiJZ1IVrWhWhZF6JlXYiWdSFa1oVoWReiZV2IlnUhWtaFaFkXomVdiJZ1IVrWhWhZF6JlXYiWdSFa1oVoWReiZV2IlnUhWtaFaFkXomVdiJZ1IVrWhWhZF6JlXYiWdSFa1oVoWReiZV2IlnUhWtaFaFkXomVdiJZ1IVrWhWhZF6JlXYiWdSFa1oVoWReiZV2IlnUhWtaFaFkXomVdiJZ1IVrWhWhZF6JlXYiWdSFa1oVoWReiZV2IlnUhWtaFaFkXomVdiJZ1IVrWhWhZF6JlXYiWdSFa1oVoXReidV2I1nUhWteFaF3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+n4w1vMzxOUHczc/P2SWD/lY6/v8EFk75PwX/e0Pbb31/fJbrR/i64d8+a1WD/nyW60e8uW3Wj3ky2+1esiX32r1kC+/1eohX36r1UO+/Farh3z5rVYP+fJbrR7y5bdaPeTLb7V6yJffavWQ9U9//TW3r7/m9vXX3L7+mtvXX3P7+mtuX3/N7euvuX39Nbevv+b29dfcvv6a29dfc/u61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWV+taX61rfbWu9dW61lfrWl+ta321rvXVutZX61pfrWt9ta711brWV+taX61rfbWu9dW61lfrWl+ta321rvXVutZX61pfrWt9ta711brWV+taX61rfaWLEzN/O6TWD+n1Q5ZDC8sWQwvPf7Hf/tA+vgGeb7+/HXn+o70dmv7bavbxLfDqoH7koHngoI9vhFcHySMH6SMH2SMH+SMHxSMHPfKNkEe+EfLIN0Ie+UboI98IfeQboY98I/SRb8THN8no6m8HzXG8OygeOSgfOageOagvD5L464M+fp0Qo/N2ULy7eh9L/ecbs28Hne+o3h9UjxzUjxw0Dxz0sYB9itTfHoKnktzvDqpHDupHDpoHDvpYyD717fp2UJzPs78+SB45SB85yB45yC8PMn930MeXPOL7QfVuP32sHV8clMcjB8kjB+kjB/3g6s3b1yiPd/eInAcO+ljiPH//2l8OOn/Xvj/owzvsKWMfbyu5vDsoHzmoHjjoY3nwFE3fLkTlu+/ex9LdKZ3E24U43t2NPhbvrg6KBy75xwLe1UH1yEH9yEHzwEEfC3lXB8kjBz3yLf9Yzrs6yB856JFvxDzyjZgHvhE/iM07tf63W1jNvDtIHjlIHznIHjnIHzkoHjkoHzmoHjmorw7qd3ejHwTpXRwkxyMHySMHffyNaIu3g+J4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","file_map":{"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"61":{"source":"// Simple Token Contract implementation in Noir\n\nfn main(\n    // The version of the HyleOutput. This is unchecked for now.\n    version: pub u32,\n    // The initial state of the contract. This is the state before the transaction is executed.\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    // The state of the contract after the transaction is executed.\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    // The identity used to execute the transaction. This is the same as the one used in the\n    // BlobTransaction.\n    identity_len: pub u8,\n    identity: pub str<256>,\n    // TxHash of the BlobTransaction.\n    tx_hash: pub str<64>,\n    // ------ Blobs ------\n    // The index of the blob being executed.\n    index: pub u32,\n    // Number of blobs used by the contract\n    // If blob_number is > 1, then you need multiple occurence of parameters group \"Blob\"\n    blob_number: pub u32,\n    // --- Blob\n    // At least one blob_index must match the index parameter\n    blob_index: pub u32,\n    blob_contract_name_len: pub u8,\n    blob_contract_name: pub str<256>,\n    blob_capacity: pub u32,\n    blob_len: pub u32,\n    blob: pub [u8; 32],\n    // ---\n    // Number of blobs in the transaction. tx_blob_count >= blob_number\n    tx_blob_count: pub u32,\n    // -------------------\n    // Weither the execution was successful or not. If false, the BlobTransaction will be\n    // settled as failed.\n    success: pub bool,\n    // ------ Private inputs ------\n    password: [u8; 32],\n) {\n    let mut id: BoundedVec<u8, 256> = BoundedVec::from_parts(identity.as_bytes(), identity_len as u32);\n    id.extend_from_slice(\":\".as_bytes());\n    id.extend_from_slice(password);\n\n    println(f\"Identity: {identity}\");\n    println(f\"Password: {password}\");\n    println(f\"extended id: {id}\");\n\n    // Hash the combined input using SHA-256\n    let input_hash = sha256::sha256_var(id.storage(), identity_len as u64 + 1 + 32);\n    println(f\"Input Hash: {input_hash}\");\n\n    assert(input_hash == blob);\n\n    assert(success == true);\n    assert(version == 1);\n    assert(initial_state_len == 4);\n    assert(next_state_len == 4);\n    assert(initial_state == [0; 4]);\n    assert(next_state == [0; 4]);\n    assert(blob_capacity == 32);\n    assert(blob_len == 32);\n    assert(blob_number == 1);\n    assert(tx_blob_count >= 1);\n}","path":"/home/laurip/src/mini/zkhackproj/noir/src/main.nr"},"64":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n","path":"/home/laurip/nargo/github.com/noir-lang/sha256/v0.1.0/src/sha256.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","build_msg_block","attach_len_to_msg_block","print_unconstrained","directive_integer_quotient","directive_invert","directive_to_radix"]}