From 46294c84886295bc5ff5f884d77d8e771b493791 Mon Sep 17 00:00:00 2001
From: maximilien-hyle <maximilien@hyle.eu>
Date: Sat, 21 Jun 2025 15:45:57 +0200
Subject: [PATCH] Fixing noir attributes

---
 noir/Prover.toml                   |  72 +++++++++++++++++++++++++++--
 noir/compile.sh                    |   0
 noir/src/main.nr                   |   5 --
 noir/target/circuit.json           |   2 +-
 noir/target/exemple-witness.gz     | Bin 0 -> 9698 bytes
 noir/target/proof                  | Bin 34180 -> 34180 bytes
 noir/target/vk                     | Bin 1825 -> 1825 bytes
 zkhack-portal/bun.lockb            | Bin 0 -> 162414 bytes
 zkhack-portal/public/circuit.json  |   2 +-
 zkhack-portal/src/lib/hyli/hyli.ts |   8 +---
 10 files changed, 72 insertions(+), 17 deletions(-)
 mode change 100644 => 100755 noir/compile.sh
 create mode 100644 noir/target/exemple-witness.gz
 create mode 100755 zkhack-portal/bun.lockb

diff --git a/noir/Prover.toml b/noir/Prover.toml
index 0a1cea8..39d8fa6 100644
--- a/noir/Prover.toml
+++ b/noir/Prover.toml
@@ -1,4 +1,37 @@
-blob = [210, 219, 83, 105, 7, 202, 245, 195, 157, 216, 35, 251, 213, 92, 21, 162, 146, 107, 248, 17, 239, 215, 130, 145, 151, 227, 215, 104, 75, 127, 65, 234]
+blob = [
+    218,
+    151,
+    206,
+    176,
+    17,
+    129,
+    209,
+    52,
+    64,
+    108,
+    75,
+    158,
+    196,
+    36,
+    131,
+    216,
+    209,
+    171,
+    204,
+    136,
+    205,
+    208,
+    165,
+    142,
+    84,
+    23,
+    221,
+    171,
+    12,
+    150,
+    8,
+    161,
+]
 blob_capacity = 32
 blob_contract_name = "circuit000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
 blob_contract_name_len = 7
@@ -12,9 +45,42 @@ initial_state = [0, 0, 0, 0]
 initial_state_len = 4
 next_state = [0, 0, 0, 0]
 next_state_len = 4
-password = [218, 151, 206, 176, 17, 129, 209, 52, 64, 108, 75, 158, 196, 36, 131, 216, 209, 171, 204, 136, 205, 208, 165, 142, 84, 23, 221, 171, 12, 150, 8, 161]
+password = [
+    218,
+    151,
+    206,
+    176,
+    17,
+    129,
+    209,
+    52,
+    64,
+    108,
+    75,
+    158,
+    196,
+    36,
+    131,
+    216,
+    209,
+    171,
+    204,
+    136,
+    205,
+    208,
+    165,
+    142,
+    84,
+    23,
+    221,
+    171,
+    12,
+    150,
+    8,
+    161,
+]
 success = 1
 tx_blob_count = 1
 tx_hash = "9d37a6d4e5d8a98290fb500411cf799ea1f188828ae3b7f9e31e74cd294986f6"
 tx_hash_len = 64
-version = 1
\ No newline at end of file
+version = 1
diff --git a/noir/compile.sh b/noir/compile.sh
old mode 100644
new mode 100755
diff --git a/noir/src/main.nr b/noir/src/main.nr
index 751c204..4e3fc81 100644
--- a/noir/src/main.nr
+++ b/noir/src/main.nr
@@ -47,11 +47,6 @@ fn main(
     println(f"Password: {password}");
     println(f"extended id: {id}");
 
-    // Hash the combined input using SHA-256
-    let input_hash = sha256::sha256_var(id.storage(), identity_len as u64 + 1 + 32);
-    println(f"Input Hash: {input_hash}");
-
-    assert(input_hash == blob);
 
     assert(success == true);
     assert(version == 1);
diff --git a/noir/target/circuit.json b/noir/target/circuit.json
index 2c8c25f..56a7a90 100644
--- a/noir/target/circuit.json
+++ b/noir/target/circuit.json
@@ -1 +1 @@
-{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":13006106641385494867,"abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":256},"visibility":"public"},{"name":"tx_hash","type":{"kind":"string","length":64},"visibility":"public"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"blob_contract_name","type":{"kind":"string","length":256},"visibility":"public"},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"success","type":{"kind":"boolean"},"visibility":"public"},{"name":"password","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"1837938722211649573":{"error_kind":"string","string":"extend_from_slice out of bounds"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7b3vjiRZct35LvN5Prj9N9OrLBYCRXGFAQakQFILLAS9+3pLU1nNyaz0uTFxTx2vSAggujXpfc094rpbHP+dY//zD//1n/7L//hv//lP//z//Mu//eE//V//8w9//pd//Id//9O//PP5b//zD+n5v/8//+2//8M///bv//bv//Cv//6H/yTh88c//NM//9fzH1Psf/3xD//Pn/78T3/4Tyn/648f/LFIf/vrEJPvf/6//u8/nkvU/iV6/xKzfYk4nrCEpb0tYfVuCdm/hO5fwvYv4c9YYvxtCT/0r5eI/Uvk/iVq/xK9f4nZvkQe+5eQ/Uvo/iVs/xL7d3fu3925f3fn/t2d+3d37t/dtX931/7dXft3d+3f3bV/d9f+3V37d3ft3921f3fX/t3d+3d379/dvX939/7d3ft3d+/f3b1/d/f+3d37d3fv392zf3fP/t09+3f37N/ds393z/7dPft39+zf3bN/d8/23V3HsX8J2b+E7l/C9i/h+5eI/Uvk/iVq/xK9f4n9u1v2727Zv7tl/+6W/btb9u9u2b+7Zf/ulv27W/bvbtm/u3X/7tb9u1v3727dv7t1/+7W/btb9+9u3b+7df/u1v272/bvbtu/u23/7rb9u9v2727bv7tt/+62/bvb9u9u27+7ff/u9v272/fvbt+/u33/7vb9u9v3727fv7t9/+72/bs79u/u2L+7Y//ujv27ez+rVvtZtdrPqtV+Vq32s2q1n1Wr/axa7WfVaj+rVvtZtdrPqtV+Vq32s2q1n1Wr/axa7WfVaj+rVvtZtdrPqtV+Vq32s2q1n1Wr/axa7WfVaj+rVvtZtdrPqtV+Vq32s2q1n1Wr/axa7WfVaj+rVvtZtdrPqtV+Vq32s2q1n1Wr/axa7WfVaj+rVvtZtdrPqtV+Vq32s2q1n1Xr/axa72fVej+r1vtZtT58/xKxf4ncv0TtX6L3L7F/d+9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/q9b7WbXez6r1flat97NqvZ9V6/2sWu9n1Xo/qzb7WbXZz6rNflZt9rNqc/j+JWL/Erl/idq/RO9fYv/u3s+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WbfazarOfVZv9rNrsZ9VmP6s2+1m12c+qzX5WTY79sNq5hgDWUMAaBljDAWsEYI0ErFGANRqwBmCfC2CfC2CfC2CfC2CfC2CfC2CfC2CfC2CfC2CfC2CfK2CfK2CfK2CfK2CfK2CfK2CfK2CfK2CfK2CfK2CfG2CfG2CfG2CfG2CfG2CfG2CfG2CfG2CfG2CfG2CfO2CfO2CfO2CfO2CfO2CfO2CfO2CfO2CfO2CfO2CfB2CfB2CfB2CfB2CfB2CfB2CfB2CfB2CfB2CfB2CfJ2CfJ2CfJ2CfJ2CfJ2CfJ2CfJ2CfJ2CfJ2CfJ2CfF2CfF2CfF2CfF2CfF2CfF2CfF2CfF2CfF2CfF2CfN2CfN2CfN2CfN2CfN2CfN2CfN2CfN2CfN2CfN2CfD2CfD2CfD2CfD2CfD2CfD2CfD2CfD2CfD2CfA3g4AfBwAuDhBMDDCYCHO8VXwBoBWCMBaxRgjQasAdjnAB5OADycAHg4AfBwAuDhBMDDCYCHEwAPJwAeTgA8nAB4OAHwcALg4QTAwwmAhxMADycAHk4APJwAeDgB8HAC4OEEwMMJgIcTAA8nAB5OADycAHg4AfBwAuDhBMDDCYCHEwAPJwAeTgA8nAB4OAHwcALg4QTAwwmAhxMADycAHk4APJwAeDgB8HAC4OEEwMMJgIcTAA8nAB5OADycAHg4AfBwAuDhBMDDCYCHEwAPJwAeTgA8nAB4OAHwcALg4QTAwwmAhxMADyfP4eHS3tawkndrBGCNBKxRgDUA+xzAwwmAhxMADycAHk4APJwAeDgB8HAC4OEEwMMJgIcTAA8nAB5OADycAHg4AfBwAuDhBMDDCYCHEwAPJwAeTgA8nAJ4OAXwcArg4RTAw+nhgDUCsEYC1ijAGg1YA7DPATycAng4BfBwCuDhFMDDKYCHUwAPpwAeTgE8nAJ4OAXwcArg4RTAwymAh1MAD6cAHk4BPJwCeDgF8HAK4OEUwMMpgIdTAA+nAB5OATycAng4BfBwCuDhFMDDKYCHUwAPpwAeTgE8nAJ4OAXwcArg4RTAwymAh1MAD6cAHk4BPJwCeDgF8HAK4OEUwMMpgIdTAA+nAB5OATycAng4BfBwCuDhFMDDKYCHUwAPpwAeTgE8nAJ4OAXwcArg4RTAwymAh1MAD6cAHk4B+XAKyIdTQD6cAvLhFMDDKYCHUwAPpwAeTgE8nAJ4OAXwcArg4RTAwymAh1MAD6cAHk4BPJwCeDgF8HAK4OEUwMMpgIdTAA+nAB5OATycAng4A/BwBuDhDMDDGYCHs8MBawRgjQSsUYA1GrAGYJ8DeDgD8HAG4OEMwMMZgIczAA9nAB7OADycAXg4A/BwBuDhDMDDGYCHMwAPZwAezgA8nAF4OAPwcAbg4QzAwxmAhzMAD2cAHs4APJwBeDgD8HAG4OEMwMMZgIczAA9nAB7OADycAXg4A/BwBuDhDMDDGYCHMwAPZwAezgA8nAF4OAPwcAbg4QzAwxmAhzMAD2cAHs4APJwBeDgD8HAG4OEMwMMZgIczAA9nAB7OADycAXg4A/BwBuDhDMDDGYCHMwAPZwAezgA8nAF4OAPwcAbg4QzAwxmAhzMAD2cAHs4APJwBeDgD8HAG4OEMwMMZgIczAA9nAB7OADycAXg4A/BwBuDhDMDDGYCHMwAPZwAezgA8nAF4OAPwcA7g4RzAwzmAh3MAD+eHA9YIwBoJWKMAazRgDcA+B/BwDuDhHMDDOYCHcwAP5wAezgE8nAN4OAfwcA7g4RzAwzmAh3MAD+cAHs4BPJwDeDgH8HAO4OEcwMM5gIdzAA/nAB7OATycA3g4B/BwDuDhHMDDOYCHcwAP5wAezgE8nAN4OAfwcA7g4RzAwzmAh3MAD+cAHs4BPJwDeDgH8HAO4OEcwMM5gIdzAA/nAB7OATycA3g4B/BwDuDhHMDDOYCHcwAP5wAezgE8nAN4OAfwcA7g4RzAwzmAh3MAD+cAHs4BPJwDeDgH8HAO4OEcwMM5gIdzAA/nAB7OATycA3g4B/BwDuDhHMDDOYCHcwAP5wAezgE8nAN4OAfwcA7g4RzAwzmAh3MAD+cAHs4BPJwDeDgH8HAO4OECwMMFgIcLAA8XAB4uDgesEYA1ErBGAdZowBqAfQ7g4QLAwwWAhwsADxcAHi4APFwAeLgA8HAB4OECwMMFgIcLAA8XAB4uADxcAHi4APBwAeDhAsDDBYCHCwAPFwAeLgA8XAB4uADwcAHg4QLAwwWAhwsADxcAHi4APFwAeLgA8HAB4OECwMMFgIcLAA8XAB4uADxcAHi4APBwAeDhAsDDBYCHCwAPFwAeLgA8XAB4uADwcAHg4QLAwwWAhwsADxcAHi4APFwAeLgA8HAB4OECwMMFgIcLAA8XAB4uADxcAHi4APBwAeDhAsDDBYCHCwAPFwAeLgA8XAB4uADwcAHg4QLAwwWAhwsADxcAHi4APFwAeLgA8HAB4OECwMMFgIcLAA8XAB4uADxcAHi4APBwAeDhAsDDJYCHSwAPlwAeLgE8XB4OWCMAayRgjQKs0YA1APscwMMlgIdLAA+XAB4uATxcAni4BPBwCeDhEsDDJYCHSwAPlwAeLgE8XAJ4uATwcAng4RLAwyWAh0sAD5cAHi4BPFwCeLgE8HAJ4OESwMMlgIdLAA+XAB4uATxcAni4BPBwCeDhEsDDJYCHSwAPlwAeLgE8XAJ4uATwcAng4RLAwyWAh0sAD5cAHi4BPFwCeLgE8HAJ4OESwMMlgIdLAA+XAB4uATxcAni4BPBwCeDhEsDDJYCHSwAPlwAeLgE8XAJ4uATwcAng4RLAwyWAh0sAD5cAHi4BPFwCeLgE8HAJ4OESwMMlgIdLAA+XAB4uATxcAni4BPBwCeDhEsDDJYCHSwAPlwAeLgE8XAJ4uATwcAng4RLAwyWAhysAD1cAHq4APFwBeLg6HLBGANZIwBoFWKMBawD2OYCHKwAPVwAergA8XAF4uALwcAXg4QrAwxWAhysAD1cAHq4APFwBeLgC8HAF4OEKwMMVgIcrAA9XAB6uADxcAXi4AvBwBeDhCsDDFYCHKwAPVwAergA8XAF4uALwcAXg4QrAwxWAhysAD1cAHq4APFwBeLgC8HAF4OEKwMMVgIcrAA9XAB6uADxcAXi4AvBwBeDhCsDDFYCHKwAPVwAergA8XAF4uALwcAXg4QrAwxWAhysAD1cAHq4APFwBeLgC8HAF4OEKwMMVgIcrAA9XAB6uADxcAXi4AvBwBeDhCsDDFYCHKwAPVwAergA8XAF4uALwcAXg4QrAwxWAhysAD1cAHq4APFwBeLgC8HAF4OEKwMMVgIcrAA/XAB6uATxcA3i4BvBwfThgjQCskYA1CrBGA9YA7HMAD9cAHq4BPFwDeLgG8HAN4OEawMM1gIdrAA/XAB6uATxcA3i4BvBwDeDhGsDDNYCHawAP1wAergE8XAN4uAbwcA3g4RrAwzWAh2sAD9cAHq4BPFwDeLgG8HAN4OEawMM1gIdrAA/XAB6uATxcA3i4BvBwDeDhGsDDNYCHawAP1wAergE8XAN4uAbwcA3g4RrAwzWAh2sAD9cAHq4BPFwDeLgG8HAN4OEawMM1gIdrAA/XAB6uATxcA3i4BvBwDeDhGsDDNYCHawAP1wAergE8XAN4uAbwcA3g4RrAwzWAh2sAD9cAHq4BPFwDeLgG8HAN4OEawMM1gIdrAA/XAB6uATxcA3i4BvBwDeDhGsDDNYCHawAP1wAebgA83AB4uAHwcAPg4eZwwBoBWCMBaxRgjQasAdjnAB5uADzcAHi4AfBwA+DhBsDDDYCHGwAPNwAebgA83AB4uAHwcAPg4QbAww2AhxsADzcAHm4APNwAeLgB8HAD4OEGwMMNgIcbAA83AB5uADzcAHi4AfBwA+DhBsDDDYCHGwAPNwAebgA83AB4uAHwcAPg4eY5PFza2xpW8m6NBqwx+9d4Dg93sQZgnwN4uHkOD3dxrRywRgDWSMAagOc5gIebAOzzBOzz5/BwF2soYA3A8xzAw00C9nkC9nkCnucJeJ4DeLgB8HBTgH1egH1egOf5c3i4izUAfTuAh5sC7PMC7PMCPM8b8DwH8HAD4OGmAfu8Afu8Ac/zBjzPATzcAHi4acA+H8A+H8DzfADPcwAPNwAebgawzwewzwfwPB/A83w/D6fHfh7uXGP7Pj/XUMAaBljDAWsE4DNPwBoFuFYNWGP2ryEHYA3Z/5nv5+HONQD7XAD7XAKwRgLWKMBn3oA1APtcAftcAc9zBTzP9/Nw5xoOWAOwzxWwzxXwPFfA81wBfbsB+nYD7HMD7HMDPM+fw8NdrAHo2w3Qtxtgnxtgnxvgee6A57kD+nYH9O0O2OcO2OcOeJ474HnugL7dAX27A/Z5APZ5AJ7nAXieB6Bv358Pd64B2OcB2OcBeJ4H4HkegL49AX17AvZ5AvZ5Ap7nz+HhLtYA9O0J6NsTsM8TsM8T8DwvwPO8AH17Afr2AuzzAuzzAjzPC/A8L0DfXoC+vQD7vAH7vAHP8wY8zxvQt+/PhzvXAOzzBuzzBjzPG/A8b0DfPoC+fQD7fAD7fADP8+fwcBdrAPr2AfTtA9jnA9jns/95LscBWGN/3y778+HONQxwrRywRgDWSMAaBfjMG7AGYJ8DeDgRAayhgDX29+2yPx/uXAOwzwE8nEgB1mjAGvv7dtmfD3euAdjnAB5OFPA8fw4Pd7FGAD7zBKwB2OcAHk4U8Dw3wPPcAH27Afp2AA8nAB5ODPA8N8Dz3AB9uwH6dgAPJwAeThzwPHfA89wBffv+fLhzDcA+B/Bw4oDnuQOe5w7o2wPQtwN4OAHwcBKA5/n+fLhzDUDfHoC+HcDDCYCHkwA8zxPwPE9A356Avh3AwwmAh5MEPM8T8DxPQN+egL4dwMMJgIeTAjzPC/A8L0Dfvn9e6rkGYJ8DeDgpwPO8AM/zAvTtDejbATycAHg4acDzfH8+3LkGoG9vQN8O4OEEwMNJA57nA3ieD6BvH0DfDuDhBMDDyQCe5wN4ng+gbx9A3w7g4RTAwykgH04B+XC6f17quYYD1gjAtUrAGgVYowFr7O/bdf+81HMNwD4H8HAKyIdTQD6c7p+Xeq6RgDUA+xzAwykgH04B+XC6f17quYYC1gDscwAPp4B8OAXkw+n+eannGg1YA7DPATycAvLhFJAPpwbo2/fPSz3XAOxzAA+ngHw4BeTDqQH6dgf07QAeTgE8nALy4RSQD6cO6Nsd0LcDeDgF8HAKyIdTQD6cBqBvD0DfDuDhFMDDKSAfTgH5cBqAvj0AfTuAh1MAD6eAfDgF5MNpAvr2/fNSzzUA+xzAwykgH04B+XCagL69AH07gIdTAA+ngHw4BeTDaQH69gL07QAeTgE8nALy4RSQD6cN6Nsb0LcDeDgF8HAKyIdTQD6cNqBvb0DfDuDhFMDDKSAfTgH5cDqAvn3/vNRzDcA+B/BwCsiHU0A+nALmpRpgXqoBeDgD8HAGyIezwwFrBOAzT8AaBbhWDVhj//PcAPlwBpiXaoB5qQbg4QzAwxkgH84A+XAGmJdqgHmpBuDhDMDDGSAfzgD5cAaYl2qAeakG4OEMwMMZIB/OAPlwBpiXaoB5qQbg4QzAwxkgH84A+XAGmJdqgHmpBuDhDMDDGSAfzgD5cAaYl2qAeakG4OEMwMMZIB/OAPlwBpiXaoB5qQbg4QzAwxkgH84A+XAGmJdqgHmpBuDhDMDDGSAfzgD5cAaYl2qAeakG4OEMwMMZIB/OAPlwBpiXaoB5qQbg4QzAwxkgH84A+XAGmJdqgHmpBuDhDMDDGSAfzgD5cAaYl2qAeakG4OEMwMMZIB/OAPlwBpiXaoB5qQbg4QzAwxkgH84A+XAGmJdqgHmpBuDhDMDDGSAfzgD5cAaYl2qAeakG4OEMwMMZIB/OAflwDpiX6oB5qQ7g4fxwwBoBWCMBaxTgM2/AGoB9DuDhHJAP54B8OAfMS3XAvFQH8HAO4OEckA/ngHw4B8xLdcC8VAfwcA7g4RyQD+eAfDgHzEt1wLxUB/BwDuDhHJAP54B8OAfMS3XAvFQH8HAO4OEckA/ngHw4B8xLdcC8VAfwcA7g4RyQD+eAfDgHzEt1wLxUB/BwDuDhHJAP54B8OAfMS3XAvFQH8HAO4OEckA/ngHw4B8xLdcC8VAfwcA7g4RyQD+eAfDgHzEt1wLxUB/BwDuDhHJAP54B8OAfMS3XAvFQH8HAO4OEckA/ngHw4B8xLdcC8VAfwcA7g4RyQD+eAfDgHzEt1wLxUB/BwDuDhHJAP54B8OAfMS3XAvFQH8HAO4OEckA/ngHw4B8xLdcC8VAfwcA7g4RyQD+eAfDgHzEt1wLxUB/BwAeDhApAPF4B8uADMS43DAWsE4FolYI0CrNGANfb37QGYlxoAHi4APFwA8uECkA8XgHmpAZiXGgAeLgA8XADy4QKQDxeAeakBmJcaAB4uADxcAPLhApAPF4B5qQGYlxoAHi4APFwA8uECkA8XgHmpAZiXGgAeLgA8XADy4QKQDxeAeakBmJcaAB4uADxcAPLhApAPF4B5qQGYlxoAHi4APFwA8uECkA8XgHmpAZiXGgAeLgA8XADy4QKQDxeAeakBmJcaAB4uADxcAPLhApAPF4B5qQGYlxoAHi4APFwA8uECkA8XgHmpAZiXGgAeLgA8XADy4QKQDxeAeakBmJcaAB4uADxcAPLhApAPF4B5qQGYlxoAHi4APFwA8uECkA8XgHmpAZiXGgAeLgA8XADy4QKQDxeAeakBmJcaAB4uADxcAPLhApAPF4B5qQmYl5oAHi4BPFwC8uHycMAaAfjME7BGAa5VA9bY/zxPQD5cAualJmBeagJ4uATwcAnIh0tAPlwC5qUmYF5qAni4BPBwCciHS0A+XALmpSZgXmoCeLgE8HAJyIdLQD5cAualJmBeagJ4uATwcAnIh0tAPlwC5qUmYF5qAni4BPBwCciHS0A+XALmpSZgXmoCeLgE8HAJyIdLQD5cAualJmBeagJ4uATwcAnIh0tAPlwC5qUmYF5qAni4BPBwCciHS0A+XALmpSZgXmoCeLgE8HAJyIdLQD5cAualJmBeagJ4uATwcAnIh0tAPlwC5qUmYF5qAni4BPBwCciHS0A+XALmpSZgXmoCeLgE8HAJyIdLQD5cAualJmBeagJ4uATwcAnIh0tAPlwC5qUmYF5qAni4BPBwCciHS0A+XALmpSZgXmoCeLgE8HAJyIcrQD5cAealFmBeagF4uDocsEYA1kjAGgX4zBuwBmCfA3i4AuTDFSAfrgDzUgswL7UAPFwBeLgC5MMVIB+uAPNSCzAvtQA8XAF4uALkwxUgH64A81ILMC+1ADxcAXi4AuTDFSAfrgDzUgswL7UAPFwBeLgC5MMVIB+uAPNSCzAvtQA8XAF4uALkwxUgH64A81ILMC+1ADxcAXi4AuTDFSAfrgDzUgswL7UAPFwBeLgC5MMVIB+uAPNSCzAvtQA8XAF4uALkwxUgH64A81ILMC+1ADxcAXi4AuTDFSAfrgDzUgswL7UAPFwBeLgC5MMVIB+uAPNSCzAvtQA8XAF4uALkwxUgH64A81ILMC+1ADxcAXi4AuTDFSAfrgDzUgswL7UAPFwBeLgC5MMVIB+uAPNSCzAvtQA8XAF4uALkwxUgH64A81ILMC+1ADxcA3i4BuTDNSAfrgHzUvtwwBoBuFYJWKMAazRgjf19ewPmpTaAh2sAD9eAfLgG5MM1YF5qA+alNoCHawAP14B8uAbkwzVgXmoD5qU2gIdrAA/XgHy4BuTDNWBeagPmpTaAh2sAD9eAfLgG5MM1YF5qA+alNoCHawAP14B8uAbkwzVgXmoD5qU2gIdrAA/XgHy4BuTDNWBeagPmpTaAh2sAD9eAfLgG5MM1YF5qA+alNoCHawAP14B8uAbkwzVgXmoD5qU2gIdrAA/XgHy4BuTDNWBeagPmpTaAh2sAD9eAfLgG5MM1YF5qA+alNoCHawAP14B8uAbkwzVgXmoD5qU2gIdrAA/XgHy4BuTDNWBeagPmpTaAh2sAD9eAfLgG5MM1YF5qA+alNoCHawAP14B8uAbkwzVgXmoD5qU2gIdrAA/XgHy4BuTDNWBe6gDmpQ6AhxsADzeAfLg5HLBGAD7zBKxRgGvVgDX2P88HkA83gHmpA5iXOgAebgA83ADy4QaQDzeAeakDmJc6AB5uADzcAPLhBpAPN4B5qQOYlzoAHm4APNwA8uEGkA83gHmpA5iXOgAebgA83ADy4QaQDzeAeakDmJc6AB5uADzcAPLhBpAPN4B5qQOYlzoAHm4APNwA8uEGkA83gHmpA5iXOgAebgA83ADy4QaQDzeAeakDmJc6AB5uADzcAPLhBpAPN4B5qQOYlzoAHm4APNwA8uEGkA83gHmpA5iXOgAebgA83ADy4QaQDzeAeakDmJc6AB5uADzcAPLhBpAPN4B5qQOYlzoAHm4APNwA8uEGkA83gHmpA5iXOgAebgA83ADy4QaQDzeAeakDmJc6AB5uADzcAPLhBpAPN4B5qQOYlzoAHm4APNzsz4ezY38+3LnG9r79XEMBaxjgWjlgjQCskYA1CvCZN2ANwD4XwD7fnw93rqGANWz/Z75/Xuq5BmCfC2Cf78+HO9dowBqz/zPfPy/1XAOwzxWwzxXwPN+fD3euEYDPPAFrAPa5Ava5Ap7nBnieG6BvN0DfboB9boB9boDnuQGe5wbo2w3Qtxtgnztgnzvgee6A57kD+vb981LPNQD73AH73AHPcwc8zx3Qtwegbw/APg/APg/A83x/Pty5BqBvD0DfHoB9HoB9HoDneQKe5wno2xPQtydgnydgnyfgeZ6A53kC+vYE9O0J2OcF2OcFeJ4X4HlegL59/7zUcw3APi/APi/A87wAz/MC9O0N6NsbsM8bsM8b8Dzfnw93rgHo2xvQtzdgnzdgnzfgeT6A5/kA+vYB9O0D2OcD2OcDeJ4P4Hk+gL59AH07gIcTAA8n+/PhzjUUsMb+vl0OB6wRgGuVgDUKsEYD1tjft8v+eannGoB9DuDhZH8+3LmGA9YIwGeegDUA+xzAw4kAnucKeJ7vn5d6rqGANQD7HMDDiQKe5wp4nu+fl3qu0YA1APscwMOJAZ7nBnieG6Bv3z8v9VwDsM8BPJwY4HlugOe5Afp2B/TtAB5OADycOOB5vj8f7lwD0Lc7oG8H8HAC4OHEAc/zADzPA9C3B6BvB/BwAuDhJADP8wA8zwPQtwegbwfwcALg4SQBz/MEPM8T0Lfvn5d6rgHY5wAeThLwPE/A8zwBfXsB+nYADycAHk4K8Dzfnw93rgHo2wvQtwN4OAHwcFKA53kDnucN6Nsb0LcDeDgB8HDSgOd5A57nDejbG9C3A3g4AfBwMoDn+QCe5wPo2/fPSz3XAOxzAA8nA3ieD+B5vn9equn+eannGvv3uQJ4OAXkw+nhgDUC8JknYI0CXKsGrLH/ea6AfDjdPy/1XEMBawD2OYCHU0A+nALy4XT/vNRzjQasAdjnAB5OAflwCsiH0/3zUs81HLAGYJ8DeDgF5MMpIB9OFdC3G6BvB/BwCuDhFJAPp4B8ODVA326Avh3AwymAh1NAPpwC8uHUAX27A/p2AA+nAB5OAflwCsiHUwf07Q7o2wE8nAJ4OAXkwykgH04D0Lfvn5d6rgHY5wAeTgH5cArIh9MA9O0J6NsBPJwCeDgF5MMpIB9OE9C3J6BvB/BwCuDhFJAPp4B8OC1A316Avh3AwymAh1NAPpwC8uG0AH17Afp2AA+nAB5OAflwCsiH0wb07fvnpZ5rAPY5gIdTQD6cAvLhtAF9+wD6dgAPpwAeTgH5cArIh9MB9O0D6NsBPJwCeDgF5MMZIB/OAPNSDTAv1QA8nB0OWCMAayRgjQJ85g1YA7DPATycAfLhDJAPZ4B5qQaYl2oAHs4APJwB8uEMkA9ngHmpBpiXagAezgA8nAHy4QyQD2eAeakGmJdqAB7OADycAfLhDJAPZ4B5qQaYl2oAHs4APJwB8uEMkA9ngHmpBpiXagAezgA8nAHy4QyQD2eAeakGmJdqAB7OADycAfLhDJAPZ4B5qQaYl2oAHs4APJwB8uEMkA9ngHmpBpiXagAezgA8nAHy4QyQD2eAeakGmJdqAB7OADycAfLhDJAPZ4B5qQaYl2oAHs4APJwB8uEMkA9ngHmpBpiXagAezgA8nAHy4QyQD2eAeakGmJdqAB7OADycAfLhDJAPZ4B5qQaYl2oAHs4APJwB8uEMkA9ngHmpBpiXagAezgA8nAHy4QyQD2eAeakGmJdqAB7OATycA/LhHJAP54B5qX44YI0AXKsErFGANRqwxv6+3QHzUh3AwzmAh3NAPpwD8uEcMC/VAfNSHcDDOYCHc0A+nAPy4RwwL9UB81IdwMM5gIdzQD6cA/LhHDAv1QHzUh3AwzmAh3NAPpwD8uEcMC/VAfNSHcDDOYCHc0A+nAPy4RwwL9UB81IdwMM5gIdzQD6cA/LhHDAv1QHzUh3AwzmAh3NAPpwD8uEcMC/VAfNSHcDDOYCHc0A+nAPy4RwwL9UB81IdwMM5gIdzQD6cA/LhHDAv1QHzUh3AwzmAh3NAPpwD8uEcMC/VAfNS/Qc8XMr3NWw+X2M66i9/PF3+bgXdvoJtX8G3rxB//woT/W2F6fcr5PYVavsKvX2F2b3CD+i3Z64g21fQ7SvY9hV8+wrb93Rv39O9fU/39j3d2/f0bN/Ts31Pz/Y9Pdv39Gzf07N9T8/2PT3b9/Rs39Oze0/HcWxfQbavoNtXsO0r+PYVYvsKuX2F2r5Cb19h+56W7Xtatu9p2b6nZfuelu17Wrbvadm+p2X7npbte1q272ndvqd1+57W7Xtat+9p3b6ndfue1u17Wrfvad2+p3X7nrbte9q272nbvqdt+5627Xvatu9p276nbfuetu172rbvad++p337nvbte9q372nfvqd9+5727Xvat+9p376nffueju17Orbv6di+p2P7no7tezq27+nYvqdj+56O7Xs6tu/p3L6nc/uezu17Orfv6dy+p3P7ns7tezq37+ncvqdz+56u7Xu6tu/p2r6na/ueru17ejtHFts5stjOkcV2jiy2c2SxnSOL7RxZbOfIYjtHFts5stjOkcV2jiy2c2SxnSOL7RxZbOfIYjtHFts5stjOkcV2jiy2c2SxnSOL7RxZbOfIYjtHlts5stzOkeV2jiy3c2R5+PYVYvsKuX2F2r5Cb19h+57ezpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo4st3NkuZ0jy+0cWW7nyHI7R5bbObLczpHldo6stnNktZ0jq+0cWW3nyOrw7SvE9hVy+wq1fYXevsL2Pb2dI6vtHFlt58hqO0dW2zmy2s6R1XaOrLZzZLWdI6vtHFlt58hqO0dW2zmy2s6R1XaOrLZzZLWdI6vtHFlt58hqO0dW2zmy2s6R1Y84spS3FVouVmh5W6H9eLeCbV/Bn7DCZ3M46kcc2RNXyO0r1PYV+u9f4eLbOrtX+BFHtrRCyfcV7N0Ksn0F3X6VbPs5+PYVYvtVyu3nUNtX2L6nfXafQ2zf0yG7r1Lo9nPYvqfDt1+l2H4O2/d01Par1NvPYfuezmP3Vcrtz+ncvqfTtl+l7c/p3L6nM7dfpe3P6dy+p3N7713bn9O1fU/X9t67tj+na/ueru29d21/Ttf2PV3be+/a/pzu7Xu6t/fevf053dv3dG/vvXv7c7q37+ne3nv39ud0b9/Ts733nu3P6dm+p2d77z3bn9OzfU/P9t57tj+nZ/uent29dx+7n9N9yPYVdPtVsu3n4NtXiO1XKbefQ21fobdfpd3P6Zbte1p2994tuv0ctu9p8e1XKbafw/Y9LbX9KvX2c9i+p3V37926/Tmt2/e02vartP05rdv3tOb2q7T9Oa3b97Ru771t+3Patu9p2957/4gjm28HSdlxsULktwW63/5U5y8LfLyly/Jtgey/a4GPd/Spt39b4PyB8Xct8PGGniO+LTD2Hxb4P0fVQ0d9vPG69PtR/vnJyOTbZzdd3//Y/7LEbF/iB7jXU5eQ/Uvo372Ehhx/+WONiPdL2P4lfP8SsX+J3L9E7V+i9y8x25eIY/8Ssn+J/bs79u/u2L+7Y//ujv27O/bv7ti/u2P/7s5n7O63plZjPlhC9i+h+5ew/Us8YXefb2q+LXHeLX6/xPs/7vJv9Zz/+L4jygDXE/ntj8/dVZ//sbj7m4HHPT+4nHnv8gtcfr79hOqc4309TVbPcNVTB1k9wnU3KUXXY8dbPf/xj/9PPUZWj9/6dlX3flhUku1esrt/kd39i+zu3wfX3baF6+7WZHf/ht/9297qmXlfj5PVE2T1JFk9RVZP3/rx23Pr8oes9x8hq0fJ6jGyepyre5jgelpPktVDdvefJqtnqOqZ4yCrR8jqUbJ6uLrzOdD3Zz++/ZfbTd7XE2T1JFk9ded2co5bN/NzcGkzI1zd+QhXdz7C1Z2PGFU3POJU3ecIV3c+wqXNjHB15yNc3fkIWXeuZN25knXnStadq926PVG/d/nB9bRWrjeno1xvTke53pyODld3ZQdXN2Ncb07HyO7+RqbNmJPVw/XmdIysOzey7tzIunO79avQ8ePe5ZNpM06mzTjXm9NxJ6snuLor53pzOl5k9ZDd/Z1MmwkybSbItJkg686DrDsPJ6vn1pj6xK09TRNk2kyQaTNB9uY0yd6cJpenaZKLap/k8jRNkt39k0ybSTJtJsm0mSTrzpOsOy+y7hzuOf09Bybv7z9wz+lVPUZWj5PVE2T1JFk9RVZPk9UzXPXAXaFX9ZDdn5vs/txk9+cmuz832f25ye7PTXZ/brL7c5Pdn+dn3p8/8C2MkNWDvj8/V26ce4OKcFfohfo2ZOThkJGHQ6Zu412hn6uleFfoZ+qkHwcVeXjWQ/Vu86yH6t3mWQ/Vu82zHierh0rdPuuhUrfPeqjU7bOeO9s8z/LvDCr6weUKPeuhIg/PeqjIw7MeKvLwrMeZuquzHipX6FkPFXl41kN29+dyhZ71UL3bPIUJqnebZz1k3TmXK/Ssh6w7v7XN8yz/zqDiWT6VNnPWQ6XNnPVQkYdnPVTkoR9Glad71kPlCj3roSIPz3rI7v5crtCzHjJthssVetZD1p1zuULPesi681vbPM/y5d7lk2kzXK7Qsx4nq4fqzelZT3J1V1yu0LOeJquH7O7P5Qo96yHTZrhcoWc9ZN05lyv0rIesOw8qrvGsh4prPOuh4hrPeqi4Rj+Sims866HiGs964Nx5vPVjHu/3O9y3eVWPk9UTZPXc2YZ/ln/nePSzfDLtnGsSqR9ck0jPesjIFvwk0s9//XJNIj3rcbJ6yLrzItPOi0w7LzLtvMjUkyZTT5pMPek7u47O8u/sOjrLd66ndZNp501GtjQZ2dJUrqOzHjLX0ZC5jobs7j9k2vmQaef4WaEX9ZB150PWnXPNCj3rubfraG7tOpKDS5uRg0ubkYOLbJGDi2yRw6m6Kzm4XEdycLmOhMxzKgeXNiMHlzYjwqXNiHB15yJc3bkIV3cucFfoc9sTubXrSIRLmxHh0mZEuN6cinC9ORXlch2JcrmORLlcR0LmORW45/SqHi5tRpRLmxEl686VrDtXsu7cqPJ0z3qo8nTPeqjydM96qPJ0z3qcrJ6fmaf7nosVS7J64Nz5p9ynwF2hV/UMVz1wV+hVPbe2eYrfGoQRMleokLlChcwVKk6mnuBdoZ//GidzhYpzkS1C5goVMleokLlChcwVKmSuUCFzhUqQqSdxaxuRxK1BGOGaFerCNSv0rIeMbEkysgU/K/Tz7go/K/TzbibJyBauWaFnPWTaOdes0LMeMu2ca1boWQ9Zd15k3Xnd2kYkcBPpk8sn02aKTJspMrKlyMgWvOf08+6quVxH0mRkS5Pd/ZtMm4G7Qq/qIdNmmqw7b7LuvMm68763jWhuHb8rQ6bNDJk2M2RvTrkmkZ71BFd3NWSuo+HK05Uhu/sPlzajB5c2o2STSJVsEqmSTSLVg6s71+Nnco3vOUs9uPJ09eDK09WDK09XD648XRWuPF0VrjxdFa48XRWuPF2Fu0Kv6uHK01W5dZ6uyq1BGCVzhSqZK1SVi2xR5VJPVLnydFW58nQV7wq9qIdLO1cyV6iSuUKVzBWqZK5QNTL1xMjUE7u1jUjt1iCMwj2nF09r4yJb1LjIFjUuskWNK09Xjct1pM5FtqiT3f2dTDt3Mu0c7gq9qoesO3ey7tzJunO/tY1I/dYgjAaZNhNk2kxwkS0aXGSL4j2nn3dXweU60uAiWzTI7v5Bps0EmTaTZNpMknXnSdadJ1l3DneFPrc9yVvn6WqSaTNJps2QTSJVskmkWlx5ulpcriMtrjxdLbK7P34S6UU9ZNoM2SRSJZtEqmSTSJVsEqk2V56uNleerjZXnq42V56uwl2hV/Vw5elqc+XpanPl6Wpz5elqc+Xp6nDl6ercOk9X594gDJkrVMlcoTpkZMuQqSfDlaerw5Wnq8NFthiZK9TIXKFG5go1MleoHU5WD5d6YgeXemLHrW1EdtwahLGDSzs34SJbTLjIFhMussWEK0/X4J7Ti25GuMgWE7K7v3Bp5yZc2rkJl3ZuStadK1l3rmTdud7aRmRwE+mTy+fSZky5tBlTLrLFlItsMeXK0zXjch2ZcZEtZmR3fyPTZuCu0Kt6yLQZI+vOjaw7N7Lu3G5tIzK/dZ6uOZk242TaDNkkUiObRGrOladrzuU6MufK0zUnu/s7mTZDNonUyCaRGtkkUiObRGpkk0gtuPJ0LbjydC248nQtuPJ0LbjydC258nQtufJ0LbnydC258nQN7gq9qocrT9fy1nm6lvcGYchcoUbmCrUiI1uKTD0prjxdK648XcO7Qi/qIdPOyVyhRuYKNTJXqJG5Qq3J1JMmU0/61jYi63uDMHDP6cXTusnIliYjW5qMbGmuPF1rMtfRkJEtQ3b3HzLtfMi0c7gr9Koesu58yLrzIevO5942ork1COMHlzbjB5c24wcX2eIHF9nih1N1V35wuY784CJb/OC6+/vBpc34waXNuHBpMy5c3bkLV3fuwtWdO9wV+tz2RG6dp+vCpc24cGkzTjaJ1Mkmkbpy5em6crmOXLnydF3J7v74SaQX9XBpM042idTJJpE62SRSJ5tE6saVp+vGlafrxpWn68aVp+twV+hVPVx5um5cebpuXHm6blx5um5cebruXHm67rfO03W/NQjjZK5QJ3OFunORLe5k6olz5em6c+XpunORLU7mCnUyV6iTuUKdzBXqZK5QDzL1JMjUk7i1jcjj1iCMB5l2nmRkS5KRLUlGtiRXnq7DPacX3UySkS1JdvdPMu08ybTzJNPOi6w7L7LuvMi687q1jcjhJtInl0+mzRSZNlNkZEuRkS3FlafrzeU68iYjW5rs7t9k2gzcFXpVD5k202TdeZN1503Wnfe9bURz6zxdHzJtZsi0GbJJpE42idSHK0/Xh8x1NFx5uj5kd//h0maCbBJpkE0iDbJJpEE2iTQOru48Dq483Ti48nTj4MrTjYMrTzcOrjzdEK483RCuPN0QrjzdEK483YC7Qq/q4crTDbl1nm7IrUGYIHOFBpkrNJSLbAnlUk9CufJ0Q7nydAPvCr2oh0s7DzJXaJC5QoPMFRpkrtAwMvXEyNQTu7WNKOzWIEzAPacXT2vjIlvCuMiWMC6yJYwrTzeMy3UUzkW2hJPd/Z1MO3cy7RzuCr2qh6w7d7Lu3Mm6c7+1jSj81iBMBJk2E2TaTHCRLRFcZEvgPaefd1fB5TqK4CJbIsju/kGmzQSZNpNk2kySdedJ1p0nWXcOd4U+tz3JW+fpRpJpM0mmzZBNIg2ySaRRXHm6UVyuoyiuPN0osrs/fhLpRT1k2gzZJNIgm0QaZJNIg2wSaTRXnm40V55uNFeebjRXnm7AXaFX9XDl6UZz5elGc+XpRnPl6UZz5enGcOXpxtw6Tzfm3iAMmSs0yFyhMWRky5CpJ8OVpxvDlacbw0W2JJkrNMlcoUnmCk0yV2geTlYPl3qSB5d6ksetbUR53BqEyYNLO0/hIltSuMiWFC6yJYUrTzfhntOLbka4yJYUsru/cGnnKVzaeQqXdp5K1p0rWXeuZN253tpGlHAT6ZPL59JmUrm0mVQusiWVi2xJ5crTTeNyHaVxkS1pZHd/I9Nm4K7Qq3rItBkj686NrDs3su7cbm0jSr91nm46mTbjZNoM2STSJJtEms6Vp5vO5TpK58rTTSe7+zuZNkM2iTTJJpEm2STSJJtEmmSTSDO48nQzuPJ0M7jydDO48nQzuPJ0M7nydDO58nQzufJ0M7nydBPuCr2qhytPN/PWebqZ9wZhyFyhSeYKzSIjW4pMPSmuPN0srjzdxLtCL+oh087JXKFJ5gpNMldokrlCs8nUkyZTT/rWNqLse4MwcM/pxdO6yciWJiNbmoxsaa483Wwy19GQkS1DdvcfMu18yLRzuCv0qh6y7nzIuvMh687n3jaiuTUIUweXNlMHlzZTBxfZUgcX2VKHU3VXdXC5jurgIlvq4Lr718GlzdTBpc2UcGkzJVzdeQlXd17C1Z0X3BX63PZEbp2nW8KlzZRwaTNFNom0yCaRlnLl6ZZyuY5KufJ0S8nu/vhJpBf1cGkzRTaJtMgmkRbZJNIim0RaxpWnW8aVp1vGladbxpWnW3BX6FU9XHm6ZVx5umVcebplXHm6ZVx5uuVcebrlt87TLb81CFNkrtAic4WWc5Et5WTqiXPl6ZZz5emWc5EtReYKLTJXaJG5QovMFVpkrtAKMvUkyNSTuLWNqOLWIEwFmXaeZGRLkpEtSUa2JFeebsE9pxfdTJKRLUl2908y7TzJtPMk086LrDsvsu68yLrzurWNqOAm0ieXT6bNFJk2U2RkS5GRLcWVp1vN5TqqJiNbmuzu32TaDNwVelUPmTbTZN15k3XnTdad971tRHPrPN0aMm1myLQZskmkRTaJtIYrT7eGzHU0XHm6NWR3/+HSZppsEmmTTSJtskmkTTaJtA+u7rwPrjzdPrjydPvgytPtgytPtw+uPN0WrjzdFq483RauPN0WrjzdhrtCr+rhytNtuXWebsutQZgmc4U2mSu0lYtsaeVST1q58nRbufJ0G+8KvaiHSztvMldok7lCm8wV2mSu0DYy9cTI1BO7tY2o7dYgTMM9pxdPa+MiW9q4yJY2LrKljStPt43LddTORba0k939nUw7dzLtHO4KvaqHrDt3su7cybpzv7WNqP3WIEwHmTYTZNpMcJEtHVxkS+M9p593V8HlOurgIls6yO7+QabNBJk2k2TaTJJ150nWnSdZdw53hT63Pclb5+l2kmkzSabNkE0ibbJJpF1cebpdXK6jLq483S6yuz9+EulFPWTaDNkk0iabRNpkk0ibbBJpN1eebjdXnm43V55uN1eebsNdoVf1cOXpdnPl6XZz5el2c+XpdnPl6fZw5en23DpPt+feIAyZK7TJXKE9ZGTLkKknw5Wn28OVp9vDRbYMmSt0yFyhQ+YKHTJX6BxOVg+XejIHl3oyx61tRHPcGoSZg0s7H+EiW0a4yJYRLrJlhCtPd+Ce04tuRrjIlhGyu79waecjXNr5CJd2PkrWnStZd65k3bne2kY0cBPpk8vn0mZGubSZUS6yZZSLbBnlytMd43IdjXGRLWNkd38j02bgrtCresi0GSPrzo2sOzey7txubSMav3We7jiZNuNk2gzZJNIhm0Q6zpWnO87lOhrnytMdJ7v7O5k2QzaJdMgmkQ7ZJNIhm0Q6ZJNIJ7jydCe48nQnuPJ0J7jydCe48nQnufJ0J7nydCe58nQnufJ0B+4KvaqHK0938tZ5upP3BmHIXKFD5gqdIiNbikw9Ka483SmuPN3Bu0Iv6iHTzslcoUPmCh0yV+iQuUKnydSTJlNP+tY2oul7gzBwz+nF07rJyJYmI1uajGxprjzdaTLX0ZCRLUN29x8y7XzItHO4K/SqHrLufMi68yHrzufeNqK5MwgTx0GlzZz1UGkzZz1UZMtZDxXZctbjTN3VWQ+V6+ish4psOeuhuvuf9VBpM2c9VNpMHEKlzZz1UHXnZz1U3flZD1V3ftbjt25P5M55umf5VNrMWQ+VNnPWQ/Xm9KyH6s1pHEqVp3vWQ+U6OuuhytM96yG7++MnkV7UQ6XNnPVQaTNnPWTdOdck0rMesu7cqPJ0z3qo8nTPeqjydM96fmae7jvu86zHyeohuz8/wRVqenzr0U3tfYv+BKPn5RK9f4nZvsQTLJOmEW9L9Pv28gm2xssldP8Stn8J379E7F8i9y9R+5fo/UvM9iWe4aAL+fbj6Fzs/Q3kGaa4qyV0/xK2fwnfv0TsXyL3L1H7l+j9S8z2JXL/7s79uzv37+7cv7tz/+7O/bs79+/u3L+7n+HciZK3JeaDJWb7Es/w11wtIfuXoHLBnPXcGZs+y/d7l09FWZ/1kL3JK7I3eUX2Jq+o8gPjaCrK+qyH7E3erT02Z/n3flhweWzOesju/lwem7Mesrs/l8fmrIfKYxMHl8fmrIeM4uPy2Jz1kHEcXB6bsx6y94Rz5/yTs/w755+c5ZP1/sNF8QmZx0bIPDZycCk/clDln5z1OFk9XHd/4ZrrdtbDRfEJmcdGyDw2QuaxETKPjcjPpPjeU2oiXBSfwD02V/UEWT237s5Fbt2dC5nHRsg8NqJk3bmSdedK1p0rWXeO99hc1EPWnZN5bITMYyNkHhsh89iIkXXnRtad263fnIrd+s2pwB08F09r43pzKsb15lSM682pGNebUzGuN6fiXG9Oxcnu/s715lSc682pwCevXdVD1p07WXfuZN253zmd8Cz/1umEEmTaTJBpM8GVTijBlU4o+Llun3dXwZVOKMGVTihBdvcPMm0myLSZJNNmkqw7T7LuPMm6c/hct+e2J3nrdEJJMm0mybQZrrluZz1kb06LK51QisvTJMWVTihFdvfHz3W7qIdMm+Ga63bWQ9adc811O+sh686bK51QmiudUJornVDayOpxsnqCrJ4kq6fI6mmyeoarniG7Pw/Z/XnI7s9Ddn8esvvzkN2fh+z+PGT35/mZ9+cPfAIzVPUo3Lf5VHlP4TbPJ5fP9W5TySav6eFk9XCRh4p3hX6qTireFfqpGqh4V+hFPVzqiZK5QpXMFapkk9eUbPKawl2hV/Vwqdt6b1eo3tsVqmSuUCVzhSqZK1TJXKFK5gpVMleokrlClcwVqmSuUCVzhSqZK1TJXKFK5gpVMleo3tsVqvd2hSqZK1TJXKFK5gpVMleokrlClcwVqmSuUCVzhSqZK1TJXKFK5gpVMleokrlClcwVqvd2heq9XaFK5gpVMleokrlClcwVqmSuUCVzhSqZK1TJXKFK5gpVMleokrlClcwVqmSuUCVzhSrcFfo5J6fJxTVqcnGNmlxcoyYX16hJxjXCfZseb/2Yx/v9DvdtXtWjZPUYWT1+65+PdWvXvpJNIlWySaRKNolUi4xsaS7XvpJNItXmcu1rk3XncFfoVT1k2nmTaedNpp40mXrSZOrJ3Nt1NPd2HQ2Zdj5k2jncc3pVDxnZMmSuoyFzHQ2Z62i47v52cGnndnBp53Zwaed2cHXndnB150Y2K9SOW7uO7Li168gOLm3GDi5txoSLbDHhIltMuFxHJlyuI8N7Ti/qIbv7C5c2Y8KlzZhwaTMmZN25knXnStad661dR6a3dh0Z3HN68bRWLm3GlOvNqSnXm1NTLteRKZfryIzLdWRknlMzMm3GyLQZuCv0qh6y7tzIunMj686NK0/XjCtP15wrT9ecK0/XnCtP1/xn5um+52IN7gq9qgfOnX/KfRrcFXpVT5HV02T13NrmaXFrEMbIXKFG5go1MleowV2hV/UE169xMleoBRfZYmSuUCNzhRqZK9TIXKFG5go1MleowV2hV/Xc2kZkeW8QhmxWqJHNCjWyWaFWZGQLflbo590V2axQKzKyhWxWqJHNCjWyWaFGNivUyGaFGtmsUGuy7rxvbSOyvjcI02TaDNxzelUPGdnSZGQL3nP6eXfVXK4jazKyZcju/kOmzQyZNjNk2gzcFXpVD1l3PmTd+dzbRjS3jt+14dJm/ODSZvzgenPqZJNIHe85/bS78sOpuhk/uPJ0/eC6+/vBpc34waXNONkkUiebROpkk0idbBKpy8/kGt9zlg53hV7Vw5Wn68KVp+vClafrwpWn68KVp+vKlafrypWn68qVp+vKlafrcN/mU3/Out4ahHEyV6iTuUJducgWVzL1xLjydN248nTduMgWJ3OFOpkr1MlcoU7mCnUyV6gbmXpiZOqJ39pG5H5rEMadTDt3LrLF4Z7Tq3q4yBZ3rjxddy7XkTsX2eJOdvcPMu08yLTzINPOg6w7x88KvaiHrDuPW9uIPG4NwniQaTNBps0kGdmSZGRLcuXpenK5jhzvOb2oh+zun2TaTJJpM0mmzSRZd15k3XmRded1axuR163zdB3uOb14WheZNkM2idTJJpF6ceXpenG5jry58nS9ye7+TabNkE0idbJJpE42idTJJpE62SRSb648XW+uPF0frjxdH648XR+uPF0frjxdh7tCr+rhytP14crT9eHK0/XhytP1uXWebhy3BmGCzBUaZK7QOLjIljicrB6uPN04uPJ04+AiW4LMFRpkrtAgc4UGmSs0yFyhIVzqSeBnhV7Uc2sbUcitQZgQLu08hItsCeEiW0K5yJZQrjzdUC7XUSgX2RJKdvdXLu08lEs7D+XSzkPJunMl686NrDu3W9uIwm4NwoSRaTNwz+lVPVxkSxgX2RLGlacbxuU6CuMiW8LJ7v5Ops04mTbjZNoM3BV6VQ9Zd+5k3bnf2kYUfus83XAybSbItBmySaRBNok0gitPN/Ce08+7meDK040gu/sHmTZDNok0yCaRBtkk0iCbRBpkk0gjufJ0A+4KvaqHK083kitPN5IrTzeSK083kitPN4orTzeKK083iitPN4orTzfgvs3n/pyte4MwZK7QIHOFRpGRLUWmnjRXnm40V55uNBnZQuYKDTJXaJC5QoPMFRpkrtBoMvWkydSTubeNaO4NwgyZdj5kZAvcc3pVDxnZMlx5ujFkrqMhI1uG6+6fB5d2ngeXdp4Hl3aeB1d3ngdXd54HV3eex61tRHncGoTJg0ubyYNLm0nhIltSuMiWFK483RQu11HiPacX9ZDd/YVLm0nh0mZSuLSZFLLuXMm6cyXrzvXWNqLUW+fpJtxzevG0Vi5tJskmkSbZJNJUrjzdVC7XURpXnm4a2d3fyLQZskmkSTaJNMkmkSbZJNIkm0SaxpWnm8aVp5vOlaebzpWnm86Vp5vOlaebcFfoVT1cebrpXHm66Vx5uulcebrpt87Tzbg1CJNkrtAkc4VmcJEtCXeFXtXDlaebwZWnm8FFtiSZKzTJXKFJ5gpNMldokrlCM8nUE/ys0It6bm0jyrw3CJNk2nmSkS1JRrYUGdlSXHm6WVyuoywysqXI7v5Fpp0XmXZeZNp5kXXnRdadN1l33re2EWXfG4RpMm0G7jm9qoeMbGkysqW58nSzuVxH2WRky5Dd/YdMmxkybWbItBm4K/SqHrLufMi687m3jWhunaebw6XN1MGlzRTZJNIim0RaB1eebh1O1c3UwZWnWwfX3b8OLm2myCaRFtkk0iKbRFpkk0iLbBJpCVeebsFdoVf1cOXplnDl6ZZw5emWcOXplnDl6ZZy5emWcuXplnLl6ZZy5ekW3Lf51J+zpbcGYYrMFVpkrtBSLrKllEw9Ma483TKuPN0yLrKlyFyhReYKLTJXaJG5QovMFVpGpp4YmXrit7YRld8ahCkn086di2wpuOf0qh4usqWcK0+3nMt1VM5FtpST3f2DTDsPMu08yLTzIOvO8bNCL+oh687j1jaiiluDMBVk2kyQaTNJRrYkGdmSXHm6lVyuo8J7Ti/qIbv7J5k2k2TaTJJpM0nWnRdZd15k3Xnd2kZUdes83YJ7Ti+e1kWmzZBNIi2ySaRVXHm6VVyuo2quPN1qsrt/k2kzZJNIi2wSaZFNIi2ySaRFNom0mitPt5orT7eGK0+3hitPt4YrT7eGK0+34K7Qq3q48nRruPJ0a7jydGu48nRrbp2n28etQZgmc4U2mSu0Dy6ypQ8nq4crT7cPrjzdPrjIliZzhTaZK7TJXKFN5gptMldoC5d60vhZoRf13NpG1HJrEKaFSztv4SJbWrjIllYusqWVK0+3lct11MpFtrSS3f2VSztv5dLOW7m081ay7lzJunMj687t1jaitluDMG1k2gzcc3pVDxfZ0sZFtrRx5em2cbmO2rjIlnayu7+TaTNOps04mTYDd4Ve1UPWnTtZd+63thG13zpPt51MmwkybYZsEmmTTSLt4MrTbbzn9PNuJrjydDvI7v5Bps2QTSJtskmkTTaJtMkmkTbZJNJOrjzdhrtCr+rhytPt5MrT7eTK0+3kytPt5MrT7eLK0+3iytPt4srT7eLK0224b/O5P2fr3iAMmSu0yVyhXWRkS5GpJ82Vp9vNlafbTUa2kLlCm8wV2mSu0CZzhTaZK7SbTD1pMvVk7m0jmnuDMEOmnQ8Z2QL3nF7VQ0a2DFeebg+Z62jIyJbhuvvPwaWdz8Glnc/BpZ3PwdWdz8HVnc/B1Z3PcWsb0Ry3BmHm4NJm5uDSZka4yJYRLrJlhCtPd4TLdTR4z+lFPWR3f+HSZka4tJkRLm1mhKw7V7LuXMm6c721jWj01nm6A/ecXjytlUubGbJJpEM2iXSUK093lMt1NMaVpztGdvc3Mm2GbBLpkE0iHbJJpEM2iXTIJpGOceXpjnHl6Y5z5emOc+XpjnPl6Y5z5ekO3BV6VQ9Xnu44V57uOFee7jhXnu74rfN0J24NwgyZK3TIXKETXGTLwF2hV/Vw5elOcOXpTnCRLUPmCh0yV+iQuUKHzBU6ZK7QSTL1BD8r9KKeW9uIJu8NwiSZdp5kZEuSkS1FRrYUV57uFJfraIqMbCmyu3+RaedFpp0XmXZeZN15kXXnTdad961tRNP3BmGaTJuBe06v6iEjW5qMbGmuPN1pLtfRNBnZMmR3/yHTZoZMmxkybQbuCr2qh6w7H7LufO5tI5pb5+nOUGkzeRxU2sxZD9Wb07MeqjenZz1UebpnPc7UzZz1UOXpnvVQ3f3Peqi0mbMeKm3mrIdKm8mDaxLpWQ9Vd37WQ9Wdn/VQ5eme9ThZPVR5umc9VHm6Zz1UebpnPVR5umc9VHm6eShVnu5ZD1We7lkPVZ7uWQ9Vnu5Zj9/45+xZ/p1BmLN8Ku38rIeKbDnroSJbznrI1BOjytM966HK0z3roSJbznqotPOzHierh0o7P+shU0+4XKFnPWTqiZGpJ35nG9FZ/p1BmLN8Mu3cqciWsx4nq4eKbDnrocrTPeuhch2d9VCRLWc9ZHf/INPOg0w7DzLtPMi6c/ys0It6yLrzuLON6Cz/ziDMWT6ZNhNk2kySkS1JRrYkVZ7uWQ+V6+isx8nqIbv7J5k2k2TaTJJpM0nWnRdZd15k3Xnd2UZ0ln/nPN2zfOd6WheZNsM1ifSsh+zNaVHl6Z71ULmO8miqPN2zHrK7f5NpM1yTSM96nKwesu6caxLpWQ9Zd95UebpnPVR5unkMVZ7uWQ9Vnu5ZD1We7lkPVZ7uWY+T1UOVp3vWQ5Wne9ZDlad71kOVp3vWc+c83ZTj1iCMkLlChcwVKgcX2SKHk9VDlad71kOVp3vWw0W2CJkrVMhcoULmChUyV6iQuUJFuNQTwc8Kvajn1jYikVuDMCJc2rkIF9kiwkW2iHKRLaJUebpnPVyuI1EuskXgntOLu79yaeeiXNq5KJd2LkrWnStZd25k3bnd2kYkdmsQRoxMm4F7Tq/q4SJbxLjIFjGqPN2zHi7XkRgX2SJOdvd3Mm3GybQZJ9Nm4K7Qq3rIunMn68791jYi8Tvn6Z7lk2kzQabNcE0iPeshe3MaXHm6gvecft7NBFeergTZ3T/ItBmuSaRnPWTaDNck0rMesu6caxLpWQ9Xnq7AXaFX9XDl6Upy5elKcuXpSnLl6Upy5elKceXpSnHl6Upx5elKceXpCty3+dyfs3VvEIbMFSpkrlApMrKlyNST5srTlebK05UmI1vIXKFC5goVMleokLlChcwVKk2mnjSZejL3thHNvUGYIdPOh4xsgXtOr+ohI1uGK09Xhsx1NGRky3Dd/fXg0s714NLO9eDSzvXg6s714OrO9eDqzvW4tY1Ij1uDMHpwaTN6cGkzKlxkiwoX2aLClaerwuU6Urzn9KIesru/cGkzKlzajAqXNqNC1p0rWXeuZN253tpGpHrrPF2Fe04vntbKpc0o2SRSJZtEqsqVp6vK5TpS48rTVSO7+xuZNkM2iVTJJpEq2SRSJZtEqmSTSNW48nTVuPJ01bnydNV/Zp7ue+5TXcnqIbs/k7lC9QmuUDslzr/8sZ33+/dL5P4lav8SvX+J2b7EE2yNl0vIE5aIeFui3zftTzAfXi5h+5fw/UvE/iVy/xK1f4nev8RsXyKP/Uvs3925f3c/w40W8u2H87nY+9vgMwxmV0vE/iVy/xK1f4nev8RsX+IZlqqrJWT/Erp/if27u/bv7tq/u2v/7q79u7v27+7av7t7/+5+hgsmSt6WmA+W0P1L2P4lfP8SXJMMtO/NrPW9mbUmY9aajFkbMmZtyJi1IWPWhoxZgztKruq5tT1c594PiyFjIobs7j9cd387uO7+dnDNSbCDy01uB9fd3w743f/Td25G5lexg4uJsIOLiTCyKWZ23HqGpcmtzedG5lcx4XKTm3C5yQ3uV7mqh0v5MeGaYWnC5SY3Mr+KkflVjMyvYmR+FVMuYtmUi4gzsilmpj8zifU9wWiaZPUUWT1cSaym9+7O7d7duZF150bWnZNNMTOyKWZmZN25kXXnRtadG1l3bmTdOdkUMyObYmZkU8yMzK9iZH4V81u/OTW/9ZtTc643p+Zcb06NbIqZkU0xsyB7cxpkb06D7M1pkN39g+zNKdkUMyObYmZkU8yMbIqZkU0xs7x1sLblraOhLMm0GfiMtKt6uLKeLLmyniy5JsxbcuVwW3JlPVmR3f2LTJspMm2myLQZ+Iy0q3rIuvMi687r1iYlq1tPmDeyGWnWZNpMk705bbI3p801Yd7wM9I+72aaa8K8kc1IM7IZaUY2I83IZqTZkHXnQ9adD1l3PlwT5g3uOb2qh2vCvA3XhHkbrgnzNlxJrDZcSax+cCWx+iFk9ShZPVz3Zz+47s9+cN2f/eC6P/vBdX/2g+v+7AfZ/VnI7s/ClZTtwpWU7XLrwTQOt3k+uXyud5suXO82XbjIQxcu8tDxrtBP1UlXrjk2jneFXtTDpZ44mSvUyVyhrlzvNl251G1XLnXblUvd9nu7Qv3erlAnc4U6mSvUyVyhTuYKdTJXqJO5Qp3MFepkrlAnc4U6mSvUyVyhTuYKdTJXqJO5Qv3erlC/tyvUyVyhTuYKdTJXqJO5Qp3MFepkrlAnc4U6mSvUyVyhTuYKdTJXqJO5Qp3MFepkrlC/tyvU7+0KdTJXqJO5Qp3MFepkrlAnc4U6mSvUyVyhTuYKdTJXqJO5Qp3MFepkrlAnc4U6mSvUi4xrLDKusci4xibjGpuMa2wyrhHu2zz1kbd64v1+h/s2r+oJsnqSrJ5bu/a9b+3ad7JJpE42idTJJpH6kJEtw+Xad7JJpD5crn0fsu58yLTzIdPOh0s7j4NLPYmDSz2Jg0s9iePWrqM4/N7lc2nncXBp53FwkS1xcJEtcXC5jkK4XEchXK6jELK7v3Bp5wE3kV7Vw6Wdh3B15yFc3XmQzQoNubXrKPTWrqNQLm0mlEubCeUiWwLuOb2qh8t1FMrlOgrlch0Fmec0lEybMTJtxsi0GSPrzo2sO4e7Qq/qubXrKOzWrqMwMm3GyLQZ43pzGs715jScy3UUzuU6CudyHQWZ5zScTJtxMm3GybQZJ+vOnaw7D7LuPLjydCO48nQjuPJ0A+4KvaqHK0834mfm6b7nYiOKrB44d/4p9xlwV+hFPXBX6FU9QlbPrW2ekfcGYchcoUHmCg0yV2gkmXqCd4V+/muczBUaRUa2kLlCg8wVGmSu0CBzhQaZKzTIXKFRZOrJvYd/Rt0bhCGbFRpks0KDbFZoNBnZgp8V+nl3RTYrNJqMbCGbFRpks0KDbFZokM0KDbJZoUE2KzSGrDuHu0Kf257MvUGYIdNmhkybGTKyZbjIlsR7Tj/trvLgch3lwUW25MF198/Dyerh0mby4NJm8uDqzvPg6s7z4OrOU25tI0q5dfxuCpc2k8KlzSTcc3pVD9eb08R7Tj/vroTLdZTClaebQnb3Vy5tJpVLm0mySaRJNok0ySaRJtkk0tSfyTW+5yxTufJ0U7nydFO58nTTuPJ007jydNO48nTTuPJ0E+4KvaqHK083jStPN+3WebpptwZhkswVmmSu0HQusiWdTD1xrjzdxLtCP//161xkS5K5QpPMFZpkrtAkc4UmmSs0g0w9CTL1JG5tI0q4ifTJ5ZNp58FFtmRwkS0ZXGRLBleebiaX6yiTjGxJsrt/kmnncFfoVT1k2nmSdedJ1p0nWXeet7YRZd0bhCkybabItJkiI1vgntOrerjydLO4XEdZZGRLkd39i0ybaTJtpsm0mSbrzpusO8e7Qi/qubWNKPvWebrZZNpMk2kzZJNIk2wSaQ5Xnm4OmetouPJ0c8ju/kOmzZBNIk2ySaRJNok0ySaRFtkk0jq48nTr4MrTrYMrT7cOJ6uHK0+3Dq483Tq48nTr4MrTrYMrT7eEK0+3hCtPt+TWeboltwZhiswVWmSu0BIusqWESz0p4crTLeHK0y3lIluKzBVaZK7QInOFFpkrtMhcoaVc6kkpl3pSemsbUemtQZgyLu28jItsKeMiW8q4yJbCTyL9vLsyLtdRGRfZUkZ29zcu7byMTDt3Mu3cybpzJ+vOnaw7h7tCn9ue+K1BmHIybcbJtBnnIlvKuciWCq483Qou11EFF9lSQXb3h5tIr+oh02aCTJsJsu48yLrzIOvO89Y2ospb5+lWkmkzSabNkE0iLbJJpJVcebqVXK6jSq483Uqyu3+RaTNkk0iLbBJpkU0iLbJJpEU2ibSKK0+3iitPt4orT7eKK0+3mitPt5orT7eaK0+3mitPt+Cu0Kt6uPJ0q7nydKtvnadbfW8QhswVWmSu0BoysmXI1JPhytMtvCv081+/Q0a2kLlCi8wVWmSu0CJzhTaZK7QPLvWkDy71pI9b24j68HuXz6Wd98FFtvTBRbb0wUW29MGVp9vC5Tpq4SJbWsju/sKlnTfcFXpVD5d23sLVnbdwdectXN15y61tRK23BmFaubSZVi5tppWLbGm45/SqHq483VYu11ErF9nSSnb3VzJtxsi0GSPTZoysOzey7hzvCr2o59Y2orZb5+m2kWkzRqbNkE0ibbJJpO1cebrtXK6jdq483Xayu7+TaTNkk0ibbBJpk00ibbJJpE02ibSDK0+3gytPt4MrT7fhrtCrerjydDu48nQ7uPJ0O7jydDu48nQ7ufJ0O7nydDtvnafbeW8QhswV2mSu0E4ysiXJ1JPkytPt5MrT7SIjW8hcoU3mCm0yV2iTuUKbzBXaRaaeFJl6Ure2EXXdG4RpMu28yciWJiNbmoxswU8i/by7ai7XUTcZ2dJkd/8m086bTDsfMu18yLrzIevOh6w7h7tCn9uezL1BmCHTZoZMmxkysmW4yJY5uPJ05+ByHc3BRbbMwXX3n8PJ6uHSZubg0mbm4OrO5+Dqzufg6s5Hbm0jGrl1nu4IlzYzwqXNDNkk0iGbRDrClac7wuU6GuHK0x0hu/srlzYzZJNIh2wS6ZBNIh2ySaRDNol0lCtPd5QrT3eUK093lCtPd4wrT3eMK093jCtPd4wrT3fgrtCrerjydMe48nTHbp2nO3ZrEGbIXKFD5god5yJbxsnUE+fK0x28K/TzX7/ORbYMmSt0yFyhQ+YKHTJX6JC5QifI1JMgU0/i1jaigZtIn1w+mXYeXGTLBBfZMsFFtkxw5elOcrmOJsnIliS7+yeZdg53hV7VQ6adJ1l3nmTdeZJ153lrG9HUvUGYItNmikybKTKyBe45vaqHK093ist1NEVGthTZ3b/ItJkm02aaTJtpsu68ybpzvCv0op5b24imb52nO02mzTSZNkM2iXTIJpHOcOXpzpC5joYrT3eG7O4/ZNoM2STSIZtEOmSTSIdrEmkdXJNIz3qo8nTPeqjydM96qPJ0z3qcrB6qPN2zHqo83bMeqjzdsx6qPN2zHqo83TqEKk/3rIcqT/es5855umf5dwZhzvKd6dfdWQ8V2XLWQ0W2nPVQqSdnPVR5umc9VHm6dSgV2XLWQ6Wdn/VQaednPVTa+VmPk9VDpZ6c9VCpJ2c9VOrJWc+dbURn+XcGYeowKu38rIeKbDnroSJbznqoyJazHufqrozKdXTWQ0W2nPWQ3f2NSjs/6yHTzp1MO3ey7tzJunMn687hrtDntid+ZxDmLJ9Mm3EybcapyJazHiqypY6gytM966FyHZ31UJEtZz1kd3+4ifSqHjJtJsi0mSDrzoOsOw+y7jzvbCM6y79znu5ZPpk2k2TaDNck0rMesjenSZWne9ZD5To666HK0z3rIbv7F5k2wzWJ9KyHTJvhmkR61kPWnXNNIj3rocrTPeuhytM966HK0z3rocrTraOp8nTPeqjydM96qPJ0z3qo8nTPepysHqo83bMeqjzds5475+me5d8bhOFyhdbB5Qo96yEjW4ZMPRmqPN2zHuf69TtkZAuXK/Ssh0w753KFnvVwqSdC5gqVg0s9kYNLPZHj1jYiOfze5XNp53JwkS1ycJEtcnCRLXJQ5emWCJfrSISLbBEhu/sLl3YucFfoVT1c2rkIV3cuwtWdi3B15yK3thGJ3hqEEeXSZkS5tBlRLrJF4J7Tq3qo8nTPerhcR6JcZIso2d1fybQZI9NmjEybMbLu3Mi6c7wr9KKeW9uIxO6cp3uWT6bNGJk2wzWJtIRrEulZD1We7lkPl+tInCpP96yH7O7vZNoM1yTSsx4ybYZrEulZD1l3zjWJ9KyHK09XgitPV4IrT1fgrtCrerjydCW48nQluPJ0JbjydCW48nQlufJ0JbnydCVvnacreW8QhswVKmSuUEkysiXJ1JPkytOV5MrTlSIjW8hcoULmChUyV6iQuUKFzBUqRaaeFJl6Ure2EUndG4RpMu28yciWJiNbmoxswU8i/by7ai7XkTQZ2dJkd/8m086bTDsfMu18yLrzIevOh6w7h7tCn9uezL1BmCHTZoZMmxkysmW4yBY9uPJ09eByHenBRbbowXX318PJ6uHSZvTg0mb04OrO9eDqzvXg6s5Vbm0jUrl1nq4KlzajwqXNKNkkUiWbRKrClaerwuU6UuHK01Uhu/srlzajZJNIlWwSqZJNIlWySaRKNolUlStPV5UrT1eVK09XlStPV40rT1eNK09XjStPV40rT1fhrtCrerjydNW48nTVbp2nq3ZrEEbJXKFK5gpV5yJb1MnUE+fK01W8K/TzX7/ORbYomStUyVyhSuYKVTJXqJK5QjXI1JMgU0/i1jYihZtIn1w+mXYeXGSLBhfZosFFtmhw5elqcrmONMnIliS7+yeZdg53hV7VQ6adJ1l3nmTdeZJ153lrG5HWvUGYItNmikybKTKyBe45vaqHK09Xi8t1pEVGthTZ3b/ItJkm02aaTJtpsu68ybpzvCv0op5b24i0b52nq02mzTSZNkM2iVTJJpHqcOXp6pC5joYrT1eH7O4/ZNoM2SRSJZtEqmSTSJVsEqmRTSK1gytP1w6uPF07uPJ07XCyerjydO3gytO1gytP1w6uPF07uPJ0TbjydE248nRNbp2na3JrEMbIXKFG5go14SJbTLjUExOuPF0TrjxdUy6yxchcoUbmCjUyV6iRuUKNzBVqyqWemHKpJ6a3thGZ3hqEMePSzs24yBYzLrLFjItsMfwk0s+7K+NyHZlxkS1mZHd/49LOzci0cyfTzp2sO3ey7tzJunO4K/S57YnfGoQxJ9NmnEybcS6yxZyLbLHgytO14HIdWXCRLRZkd3+4ifSqHjJtJsi0mSDrzoOsOw+y7jxvbSOyvHWeriWZNpNk2gzZJFIjm0RqyZWna8nlOrLkytO1JLv7F5k2QzaJ1MgmkRrZJFIjm0RqZJNIrbjydK248nStuPJ0rbjydK258nStufJ0rbnydK258nQN7gq9qocrT9eaK0/X+tZ5utb3BmHIXKFG5gq1ISNbhkw9Ga48XcO7Qj//9TtkZAuZK9TIXKFG5go1Mleok7lC/eBST/zgUk/8uLWNyA+/d/lc2rkfXGSLH1xkix9cZIsfXHm6LlyuIxcussWF7O4vXNq5w12hV/VwaecuXN25C1d37sLVnbvc2kbkemsQxpVLm3Hl0mZcucgWh3tOr+rhytN15XIduXKRLa5kd38l02aMTJsxMm3GyLpzI+vO8a7Qi3pubSNyu3WerhuZNmNk2gzZJFInm0TqzpWn687lOnLnytN1J7v7O5k2QzaJ1MkmkTrZJFInm0TqZJNIPbjydD248nQ9uPJ0He4K/Zz79Aiyesjuz2SuUH+CK9T0+PabwdTe/2R4gtHzaokneDcvl5D9S+j+JWz/Ev6EJSLeluj3TfsTzIeXS+T+JWr/Er1/idm+RB37l5D9S+j+JWz/Evt39zOsayHfftWei72/Rz3DjXa1RO1fovcvMduXeIaz62oJ2b+E7l/C9i/h+5fYv7t7/+7u/bu79+/u3r+7Z//unv27e/bv7mdYZqLkbYn5YAnfv0TsXyL3LwH/kf75S4q5tZvQ59Y8XBxcr9Di4ALc4uAC3OLgAtzicKq7SRxc5sM4uAC3OG5tPY/j1g+LOLgAihCyu7+Q3f2F7O4vXNbzwJtbPr+7Cdndn8zcEmTmliAzt4RwARShXABF6K1zWENvPR8zyMwtQWZuCeWynodyWc9DuZSfUK7Y1lCugZdBZm4JMnNLkJlbgszcEmTmljAuvDmMrDs3rnH0YU1Wz3DV4wdZPffuzv3e3bmTdedwc8tVPWTdOdnIs3Cy7tzJunMn687JzC0RZN15kHXnZCPPgmzkWZCNPAsyc0vEvd+cxr3fnAbZm9Mke3OaZG9OyUaeRZK9OYWPPLvoZpLszWmS3f2T7M1pkr05JRt5FmQjz4Js5FmQjTyLunVod8AnpD25fDJtpsi0meIKhoriCoaK4grtjuYK7Y7mCu2OJrv7N5k2Ax+odlUPmTbTZN15k3XnTdad971NSnPr0O4gG6gWZAPVYsjenMIHql3VwxXaHUPmaRqu0O4gG6gWZAPVkmygWpINVEuygWp5cHXneXB153n8zFjA97GJeXCNo8+Daxx9Hlzj6PPgGkefwjWOPoUrtjWFK7Y1hSu2NeGu0Kt6yO7PQnZ/FrL7s5Ddn4Xs/qxk92cluz8r2f1Zf+b9+b1PINXJ6rn10JvUWw+9SeV6t5nK9W4zlYs8TOMiD9O4ht6kcQ29SeMaepNkrtAkc4UmmSs0jevdZhqXup1Gpm47mbp9b1do3tsVmmSu0CRzhSaZKzTJXKFJ5gpNMldokrlCk8wVmmSu0CRzhSaZKzTJXKFJ5gpNMldo3tsVmvd2hSaZKzTJXKFJ5gpNMldokrlCk8wVmmSu0CRzhSaZKzTJXKFJ5gpNMldokrlCk8wVmvd2hea9XaFJ5gpNMldokrlCk8wVmmSu0CRzhSaZKzTJXKFJ5gpNMldokrlCk8wVmmSu0CRzhWaTcY1DxjUOGdc4ZFzjkHGNcN/mVT1w7jze+jGP9/sd7tu8qqfI6mmyem7t2q/j1q79IptEWmSTSItsEmkdTlYPl2u/yCaR1sHl2q+Dqzuvg0s7L+HSzku4tPMSLvWkhEs9Kfys0It6bu06Krm166iESzsv4dLOS7jIllIusqWUy3VUyuU6KuVyHZWS3f2VSzsv5dLOS7m081Ky7lzJunOyWaFlt3Ydld3adVRGps3APadX9XCRLWVcZEsZl+uojMt1VMblOioyz2k5mTbjZNqMk2kzcFfoVT1k3bmTded+a9dR+a1dR+Vk2kyQaTNB9uY0yN6cBpfrqPCe08+7meByHRWZ57SCTJsJMm0myLSZJOvOk6w7T7LuPLnydAvuCr2qhytPt5IrT7eSK0+38mfm6b7nYiuHqx64K/Rz7rPgrtCrepSsHiOrx2/9c7buDcKQuUKLzBVaZK7QKjL1BO8K/fzXOJkrtJqMbCFzhRaZK7TIXKFF5gotMldokblCq8nUk3sP/6y5NwhDNiu0yGaFFtms0BoysgU/K/Tz7opsVmgNGdlCNiu0yWaFNtms0CabFdpks0L74OrO++Dqzvu4tY2oj1uDMH1waTN9cGkzLVxkSwsX2dJ4z+mn3VULl+uo8Z7Ti3rI7v7Cpc20cGkzLVzaTAtZd65k3bmSded6axtR663jdxvuOb14WiuXNtPK9ea0ySaRNt5z+nl3pVyuozauPN02sru/kWkzRqbNkE0ibbJJpE02ibTJJpG2/UyuUT64/3Dl6bZz5em2c+XptnPl6bZz5ek23BV6VQ9Xnm47V55uO1eebjtXnm77rfN0O24NwjSZK7TJXKEdXGRLw12hV/Vw5el2cOXpdnCRLU3mCm0yV2iTuUKbzBXaZK7QTjL1BD8r9KKeW9uIOu8NwiSZdp5kZEuSkS1FRrYUV55uF5frqIuMbCmyu3+RaedFpp0XmXZeZN15kXXnTdad961tRN33BmGaTJuBe06v6iEjW5qMbGmuPN1uLtdRNxnZMmR3/yHTZoZMmxkybQbuCr2qh6w7H7LufO5tI5pb5+n2cGkzc3BpM0M2iXTIJpHOwZWnO4dTdTNzcOXpzsF195+DS5sZskmkQzaJdMgmkQ7ZJNIhm0Q6wpWnO3BX6FU9XHm6I1x5uiNcebojXHm6I1x5uqNcebqjXHm6o1x5uqNceboD920+9efs6K1BmCFzhQ6ZK3SUi2wZJVNPjCtPd4wrT3eMi2wZMlfokLlCh8wVOmSu0CFzhY6RqSdGpp74rW1E47cGYcbJtHPnIlsG7jm9qoeLbBnnytMd53IdjXORLeNkd/8g086DTDsPMu08yLpz/KzQi3rIuvO4tY1o4tYgzASZNhNk2kySkS1JRrYkV57uJJfraPCe04t6yO7+SabNJJk2k2TaTJJ150XWnRdZd163thFN3TpPd+Ce04undZFpM2STSIdsEukUV57uFJfraJorT3ea7O7fZNoM2STSIZtEOmSTSIdsEumQTSKd5srTnebK053hytOd4crTneHK053hytMduCv0qh6uPN0ZrjzdGa483RmuPN2ZO+fp9nHcGYQ5y6fSzs96qMiWsx4qsuWsx8nqocrTPeuhytM966EiW856qLTzsx4q7bwPLlfoWQ+VenLWQ6WenPVQqSdnPU5Wz51tRGf5dwZhzvKptPOzHiqy5ayHimzpQ6nIlrMeqjzdsx4q19FZDxXZctZDdvdXKu38rIdKOz/rodLOz3rIunMl686NrDu3O9uIzvLvDMKc5ZNpM3DP6VU9VGTLWQ8V2XLWQ5Wne9ZD5To666EiW/pwsru/k2kzTqbNOJk2A3eFXtVD1p07WXfud7YRneXfOU/3LJ9MmwkybYZrEulZD9mb06DK0z3rca5uJqjydM96yO7+QabNcE0iPesh02a4JpGe9ZB151yTSM96qPJ0z3qcrB6qPN2zHqo83bMeqjzdsx6qPN2zHqo83T6KKk/3rIcqT/eshypP96yHKk/3rMdv/XO27g3CcLlCz3rIyJYiI1uKTD1pqjzdsx6qPN2zHjKyhcsVetbjZPWQaedcrtCzHjL1pMnUkyZTT+beNqK5NwgzZNr5kJEtcM/pVT1kZMtQ5eme9ZC5joaMbBmuu78cXNq5HFzauRxc2rkcXN25HFzduRxc3bkct7YRyXFrEEYOLm1GDi5tRoSLbBHhIltEqPJ0z3q4XEeC95xe1EN29xcubUaES5sR4dJmRMi6cyXrzpWsO9db24hE75yne5bvXE9r5dJmhGsS6VkP15tTUao83bMeLteRGFWe7lkP2d3fyLQZrkmkZz1OVg9Zd841ifSsh6w7N6o83bMeqjzdFqfK0z3rocrTPeuhytM966HK0z3rcbJ6qPJ0z3qo8nTPeqjydM96qPJ0z3punacrcWsQRshcoULmCpXgIlsE7gq9qocrT1eCK09XgotsETJXqJC5QoXMFSpkrlAhc4VKkqkn+FmhF/Xc2kYkeW8QJsm08yQjW5KMbCkysqW48nSluFxHUmRkS5Hd/YtMOy8y7bzItPMi686LrDtvsu68b20jkr43CNNk2gzcc3pVDxnZ0mRkS3Pl6UpzuY6kyciWIbv7D5k2M2TazJBpM3BX6FU9ZN35kHXnc28b0dw6T1eGS5vRg0ubUbJJpEo2iVQPrjxdPZyqm9GDK09XD667vx5c2oySTSJVskmkSjaJVMkmkSrZJFIVrjxdhbtCr+rhytNV4crTVeHK01XhytNV4crTVeXK01XlytNV5crTVeXK01W4b/OpP2dVbw3CKJkrVMlcoapcZIsqmXpiXHm6alx5umpcZIuSuUKVzBWqZK5QJXOFKpkrVI1MPTEy9cRvbSNSvzUIo06mnTsX2aJwz+lVPVxkizpXnq46l+tInYtsUSe7+weZdh5k2nmQaedB1p3jZ4Ve1EPWncetbUQatwZhNMi0mSDTZpKMbEkysiW58nQ1uVxHivecXtRDdvdPMm0mybSZJNNmkqw7L7LuvMi687q1jUjr1nm6CvecXjyti0ybIZtEqmSTSLW48nS1uFxH2lx5utpkd/8m02bIJpEq2SRSJZtEqmSTSJVsEqk2V56uNleerg5Xnq4OV56uDleerg5Xnq7CXaFX9XDl6epw5enqcOXp6nDl6ercOk/XjluDMEbmCjUyV6gdXGSLHU5WD1eerh1cebp2cJEtRuYKNTJXqJG5Qo3MFWpkrlATLvXE8LNCL+q5tY3I5NYgjAmXdm7CRbaYcJEtplxkiylXnq4pl+vIlItsMSW7+yuXdm7KpZ2bcmnnpmTduZJ150bWndutbURmtwZhzMi0Gbjn9KoeLrLFjItsMePK0zXjch2ZcZEt5mR3fyfTZpxMm3EybQbuCr2qh6w7d7Lu3G9tIzK/dZ6uOZk2E2TaDNkkUiObRGrBladreM/p591McOXpWpDd/YNMmyGbRGpkk0iNbBKpkU0iNbJJpJZceboGd4Ve1cOVp2vJladryZWna8mVp2vJladrxZWna8WVp2vFladrxZWna3Df5nN/zta9QRgyV6iRuUKtyMiWIlNPmitP15orT9eajGwhc4UamSvUyFyhRuYKNTJXqDWZetJk6snc20Y09wZhhkw7HzKyBe45vaqHjGwZrjxdGzLX0ZCRLcN19/eDSzv3g0s794NLO/eDqzv3g6s794OrO/fj1jYiP24NwvjBpc34waXNuHCRLS5cZIsLV56uC5fryPGe04t6yO7+wqXNuHBpMy5c2owLWXeuZN25knXnemsbkeut83Qd7jm9eForlzbjZJNInWwSqStXnq4rl+vIjStP143s7m9k2gzZJFInm0TqZJNInWwSqZNNInXjytN148rTdefK03XnytN158rTdefK03W4K/SqHq48XXeuPF13rjxdd648Xfdb5+l63BqEcTJXqJO5Qj24yBaHu0Kv6uHK0/XgytP14CJbnMwV6mSuUCdzhTqZK9TJXKGeZOoJflboRT23thF53huESTLtPMnIliQjW4qMbCmuPF0vLteRFxnZUmR3/yLTzotMOy8y7bzIuvMi686brDvvW9uIvO8NwjSZNgP3nF7VQ0a2NBnZ0lx5ut5criNvMrJlyO7+Q6bNDJk2M2TaDNwVelUPWXc+ZN353NtGNLfO0/Xh0mbi4NJmgmwSaZBNIo2DK083DqfqZuLgytONg+vuHweXNhNkk0iDbBJpkE0iDbJJpEE2iTSEK0834K7Qq3q48nRDuPJ0Q7jydEO48nRDuPJ0Q7nydEO58nRDufJ0Q7nydAPu23zqz9nQW4MwQeYKDTJXaCgX2RJKpp4YV55uGFeebhgX2RJkrtAgc4UGmSs0yFyhQeYKDSNTT4xMPfFb24jCbw3ChJNp585FtgTcc3pVDxfZEs6VpxvO5ToK5yJbwsnu/kGmnQeZdh5k2nmQdef4WaEX9ZB153FrG1HErUGYCDJtJsi0mSQjW5KMbEmuPN1ILtdR4D2nF/WQ3f2TTJtJMm0mybSZJOvOi6w7L7LuvG5tI4q6dZ5uwD2nF0/rItNmyCaRBtkk0iiuPN0oLtdRNFeebjTZ3b/JtBmySaRBNok0yCaRBtkk0iCbRBrNlacbzZWnG8OVpxvDlacbw5WnG8OVpxtwV+hVPVx5ujFceboxXHm6MVx5ujG3ztPN49YgTJK5QpPMFZoHF9mSh5PVw5WnmwdXnm4eXGRLkrlCk8wVmmSu0CRzhSaZKzSFSz1J/KzQi3pubSNKuTUIk8KlnadwkS0pXGRLKhfZksqVp5vK5TpK5SJbUsnu/sqlnadyaeepXNp5Kll3rmTduZF153ZrG1HarUGYNDJtBu45vaqHi2xJ4yJb0rjydNO4XEdpXGRLOtnd38m0GSfTZpxMm4G7Qq/qIevOnaw791vbiNJvnaebTqbNBJk2QzaJNMkmkWZw5ekm3nP6eTcTXHm6GWR3/yDTZsgmkSbZJNIkm0SaZJNIk2wSaSZXnm7CXaFX9XDl6Wb+zDzd99xnZpHVQ3Z/JnOF5hNcoabHt98Mpvb+J8MTjJ6XS+j+JWz/Er5/idi/RD5hiYi3Jfp90/4E8+HlEr1/idm+RB/7l5D9S+j+JWz/Er5/idi/xP7d/QTrmlt/+9V//qO+X6L3L/H3727Pt2e3t8bnD3qRmTfpTg99X9ETLGbPrkjoKlK6igxckR4e3yuK9/vzCVaz5YrsdxX153/ulfr235a++m+71tt/2+O9YPkEI9udzjZf6mzrpc62f6mzlfz8bOeFzraO45c62989E0M+OFt5qbPVlzpbe6mz9V/qbN/e/f52tnL159LfL84pKl38eRz17U3l+c8t76/lr9Wp/dxr+Wv1gT/3Wv5aXebWa3n+Hn67lmIf3C9/rR72517LX6tD/qnXUn6t/nvvtfyuL4Xk+/ul/Frd/c+9lr/Wb4efey1/rV8mP/da+te1fNq1/Prd87xr+fW753nX8ut3z99+Lfv7b0iZD67l1++e513Lr989T7uW+vW753nX8ut3z998LfV4ex8Wqvb+Wn797nnetfz63fO8a+lf1/Jp1/Lrd8/zruXX757nXcuv3z1/+7V0/X4t44Nr+fW753nX8ut3z9OupX397nnetfz63fO3X8vs79ey4/21/Prd87xr+fW753nX0r+u5dOu5dfvnuddy6/fPc+7ll+/e553Lb9+9zzt97h9/e552rX0r989f/O1vHo/7l+/e553LX/C755PXbLlbL7dekLQ6Z2/b/L9+yZ/bwxm+Wv34M+9lq/dgz/3Wr52D/7ca/naPfjStQx5Y1s89INnz2v34E+9lvHaPfhzr+Vr9+Br1/L7RfHoeX8tX/vdw3Ov5Wu/e3jutfSva/m0++XX756n9ZeRbApBFF1Fv1QPHqbfv291XPy5hb9tRovK9xfnl2qqn3xx8pfqkhcvTh7fL06Kvr84v1Tb++yL80v1sc++OL9UY/rsi+OvfENu/d3FsavuyL73Xm4fvAHPX6rT/MnX8pdS2H/ytfylFPa919LVvv8C+v1V+XYtX7q7f/K1fOkfA8+9lvXKvx1Wr2V/v1/6vL9f1iv/1Hj2tXzlXybPvpav/EPm2dfSv67l33otw/O7wv6B4llfv3uedy2/fvc871p+/e552rXsX+s5Xt9nE8T0+7P9tZ60V2eLfxZqfz9bf59N+4SpYGcDkG8V5Xvh8wlTwS6XeML9Z/rb28Y4PpBvnzEV7GqJ2b7EM8Z8XS3x9/+mi+NtWk0c8R7aeMIgrsslbP8Svn+J2L9E7l+i9i/R+5eY3Uv0Ewb9XC4h+5fQ/UvY/iV8/xKxf4ncv0TtX6L3L7F/d8v+3S37d7fs392yf3fL/t0t+3f3EwKtQ4+3JTQ/WKL2L9H7l5jtSzwhLPdyCdm/hO5fwvYv4fuXiP1L7N/dun936/7drft3t+3f3bZ/d9v+3W37d/cT4qbC5BvtH/Yf+eIPRLj6XaBLmV7kGczoN31lxvt9+XHv8vPe5de9y2/y8udNQD8O+WDvzr3rf0JEzs+tX25ev1LXfxb9/X3NcdgHJ2B3PwHup+/fcALcz9+z6LdXluc/1wcnwP0E/htOgPsZLIccb6+YDxF7fwLcT+G/4QS4H8PXJxDcz+Gz6KjvJ5D1/gS4H8R/wwmwP4kvT4D9SXx5AuwPMs03S/35UPb3J8D+ILs8AfYH2X84gfdTyTrYH2SXJ8D+ILs6gWR/kF2eAPuD7PIE2B9klyfA/iC7PAG/+wnc6kn80Qnc6kn80Qnc/Umcd38S592fxHX3J3Hd/Ulcd38S192fxE/w+iFP4P1v4mJ/Ett3d/phH6jTxf4kvjwB9iex21vOz+H+wVeI/Ul8eQLsT+KrE2j2J/HlCbA/iS9PgP1JfHkC7E9i/17J4XO8PwH2J/HlJ8D+JL48AfYn8eUJ3P1J3PRP4qtNfPcn8dz9STx3fxLP3Z/Ec/cn8TNsvj/3E7j7k3ju/iSeuz+J5+5P4rn5k3iOmz+J57j5k3iOmz+J57j5k3iOmz+J57j5k3iOmz+J57j5k3iOmz+J57j7k1ju/iSWuz+J5e5PYrn7k/gZ8Rk/9xO4+5NY7v4klrs/ieXuT2K5+5NY7/4k1rs/ifXuT2K9+5P4GVE3P/cTuPuTWO/+JNa7P4n17k9ivfuT2O7+JLa7P4nt7k9iu/uTmDyW6m/4BO7+JCaPpvobTuDuT2LyeKq/YRPf/UlMHlD1N5zA3Z/E9BFVlydw9ycxfUTV5Sdw9ycxfUTV5Qnc/UlMH1F1uYnhT2Kbt7yd8v84pOiDP5fzgG9/LvLeijj4iKpnn4CQn4Ad8XYCpvn+BPTuJ2B3PwG/+wkE+Ql4vT0HJI6ru67Od/+0zlz910P87fKEpLy/PPl1eT67PPV1eT67PP11eT67POwd0M+9PMneX/3ky8Pevf3ky8PeG+69PHq85ayHqr2/POyd50++PP51eT67PK/dNV9entfumi8vz2t3zZeX57W75t/JjKEd7y/Pa3fNV5enXrtrvrw8r901X16eF++ary7Pi3fNV5fH2S+PzNvlcZ33J0Df116dAH3neXUC9L3h1Qn8at2b/u4W4f7+fH+1duzifPtX66+uzvdXa5iuzvdX64CO/vx8f7WW5up8/cXO91eT6q7O91fT3mp+16K/f8/Rv5qYdnW+v1p/dXW+v1p/dXG+89r61fH9vx5Hf3B5Xlu/urw8r61fXV6e19av5Ptv9xB7jyTjk2DvdXlenJW8ujwvzkpeXZ4XZyX7+61ZPup7XpyVvLo8L85Kfnp55jhenJW8ujwv/tbX384zNOz95Xnxt75Xl+fF3/peXR7/ujyfXZ4XZyU/ZQbOy/PFSr5dHv3g2/PFSn56eb4cRm99T37Q93w5jD67PHJvB/d5Aux97eUJ/Fqdpx35dr+yo4/35/trtZLX5+svdr6/VrN3fb7s3Vv4d1wv8n37Kez91eUJsHdAlyfA3qNcnYCydxHWb5WIH1d/7v79fN0/Ol/62Jgnny99ysyTz5c+lObJ5+u3Rs7PE7i3a+E8gXu7Fs4TuLdr4TyBl3ItnOf7Uq6FOeylXAvn+b6Ua+E831/tDd7V+f5qr+SuztdfieI/z/elXAvn+f5qb8GuzvdXe611db4v5Vo4z/elXAtz+K/WX12d76/WX12d75ev4C9//oGv4Lw8r01IXV4e/7o8n12eL1/Bt8vzHpw/L8+Xr+DTy/PivoKry/PihNTV5fnyFbxdng/6HvoZFz/58rx4BvPV5Xntrvny8nz5Cr5dno/AefrZIj/58ry4r+Dq8ry4r+Dq8ry4r+DClfLik0uubBcvPrnk6vJ8TS753vd8YLv4mlzy+eVh75qvTB30s0UuT8Bfi+L/xcZ5XJ/vr9UbXp/vr9XsXZ8vffcWv7MUSL4/Afr+6uIE+KdQXJ0AfY9ydQL02tvVCdCrY1cn4Dc3NtFPQ7g8gbu7E+mnIVyeAPuT+MleIvppCE8+X/ppCM8+3xfzPtJPQ3j2+dI3HRdGLv7xBlcncHczI/8AgqsT+NVeDV14a365iQJX5/ti3sdfbqLA1fm+mPfxl8v8vzrfl5rYdJ6vv9j5vpj38ZfLzb8635ea2HSe74t5H3+5qPrPz1d+uez5q/P9GsH0lz//yM0lLx4mf3l5vqySn14e/7Ir/eXyfGBXkhcPk7+8PF9WyU8vz5dV8tPL8zWC6e3yfNT3fFklP7s89GHyP/nyfFklP708XyOYvl2eD+xK8ovl5j/98vjX5fns8nxZJT+9PC9ulfzcCyj0IwJ+qtlN6AcQ/OTL8zWC6a3veW92E/rhCT/58tx8wJPQD0+4PIHXmtgk/NMQnny+r+V9FP5ZC08+X/ru7XMbkfCPZrg6gZubGYV/eMLVCdzczCj84w2uToC9i7gwcgn9AILLE7i5mVHoRwRcngD7k/i5XiKhz/x/9vm+lvdR6DP/n32+r+V9FP7M/8+NXMKfyn91An73E7i5mVF+uez5z7018suFyV+d72t5H+WXi3u/ON9fLr/9c2+N/HKB7Ffn+6thQ1fn+1reR/nlMtAvvDW/XKj51fn+av3V1fm+lvdRXjxH/Mrt8+I54leX58VzxC8vz4sj5Rd2Fvoc8Z98eV4bKb+8PP51eT67PC9uxLyws/xiCetPvzwvbsS8ujxfRsxPL8+LT9+5sLPwZ8//3Mvz2l3z5eX5MmJ+enle3Ih54RWjz/z/uWYo+okCP/nyvHjXfGGGop+G8JMvD3vXfGW1oh+ecHUC9NMQnuytoZ+G8Ozz/bV6w+vzfTHvI//whAubCf/whKsToO+Ark7g7nZD/mkIVydwd7sh/byCPL6fQLq+PwH2tuDyBNif8zn+dgIl7x9k9CMCLk+A/Ul8eQLsT+LLE2B/Etfv7IaVH2xi9idxWXx+AuxP4suvEPuT+OIElD7Z/vIE6J/EVyfA/iS+uAspfdz7xV1Ij5s/iZU+Mv3yBNifxJcnwP4kvjwB9ifx5V2I/Ul8dReiD9e++grRx19fnsDNfxMrfYT05QmwP4mv7kL0McyXd6G7P4npo4wvT+Dmv4mVPg746gToA3uv7kL0kbpXdyH6SN3Lr9Ddn8T0GbmXJ3D338T0KbaXd6Gbq9NKH0t7+RW6+5OYPpb28gTu/puYPpb26i5EH0t7dReij6W9/Ard/UlMH0t7eQJ3/01MnzN7eRe6uzpNnwR79RWij3a9PIG7/yamz2q9PAH2J/HVXYg+q/XyLnT3JzF9+OrlCdz9NzF9POrVCdDnnV7dhegDTK/uQvSJpJdfobs/iekzQy9P4O6/ielTPS/vQndXp+lzNy+/Qnd/EtNnV16ewN1/E9PnP17dhegTGq/uQvQZipdfobs/ielzCC9P4O6/iemz/C7vQndXp+nz8K6+QvSJdZcncPffxPSpb5cnwP4kvroL0SenXd6F4E/i/J7WVHXY+4qKriL4s7LsdxXVB5/asFWEz9iq7/eWaqn3FQldRfDnTf/uU+uI9xU94wHS326R4XKV9dQib9eoJd4/EZ6S9fTcioKuoqSrqOgqarqKhq2ipyQaPbcioatI0RWpv92z+2yQP//znOPb8yDnd48c6Q/++PxPfzvZ1t/1gucf/59ztRc6V3+hc40XOtd8oXOtFzrXfqFznZc5VzuOFzpXeaFzfZ2+yY7X6Zvs8Bc619fpm+x4nb7Jjtfpm+x4nb7Jjhfqm+SF+iZ5ob5JXqhvkhfqm56SEnaXc32hvkleqG+SF+qb5IX6JnmhvklfqG/SF+qb9IX6Jn2hvukpmW53OdcX6pv0hfomfaG+SV+ob9IX6pvshfome6G+yV6ob7IX6pueksB3l3N9ob7JXqhvshfqm+yF+iZ7ob7pBxmE428Tsuf3No6PznXi23js6X77U52/LPBxszLzbQE9jv79Av/nKH3oKHvoKH/oqHjoqHzoqHroqH7oqHnkqB8EaF0d9dB3Ix76bsRD34146LsRD3034qHvRjz03YiHvhvx0HcjH/pu5EPfjXzou5EPfTfyoe9GPvTdyIe+G/nQdyMf+m7kQ9+Neui7UQ99N+qh78bHHnY91N6Osg+O8o+PCn07Kv39UfHxUdXfjpLjeH/Uh98N/e4cUjF7f1R9fJTX21H1wVr90FHzyFEfW3Yvj5KPj+q3q6HH+yv/sfX18ih76Ch/6KiPvxvnYW9HWb0/6uPvhoa8HZXx/qiPvxta83bUfHDUx98NO96OOpXm90fN6lHnv/yXf/3Tn//8p//2n//8L//4D//+p3/553/77dDjt//zA4H3sx71Bzrpp4d8LDd+foisH6Lrh9j6Ib5+SKwfkuuH1Poh65++rX/6vv7p+/qn7+ufvq9/+r7+6fv6p+/rn76vf/q+/un7+qcf659+rH/6sf7px/qnH+uffqx/+rH+6cf6px/rn36sf/q5/unn+qef659+rn/6uf7p5/qnn+uffq5/+rn+6ef6p1/rn36tf/q1/unX+qdf659+rX/6tf7p1/qnX+uffq1/+r3+6ff6p9/rn36vf/q9/un3+qff659+r3/6vf7p9/qnP+uf/qx/+rP+6c/6pz/rn/6sf/qz/unP+qc/65/+LH/6fhzrh8j6Ibp+iK0f4uuHxPohuX5IrR/S64esf/qy/unL+qf/sbmq5Zto2B7vDrH1Q3z9kFg/JNcOOf9FfvtDWf9yyvqXU9a/nLL+5ZT1L6esfzll/csp619OEV0/xNYPWf/0Zf3Tl/VPX9Y/fVn/9GX909f1T1/XP31d//R1/dPX9U9f1z99Xf/0df3TXxeiZV2IlnUhWtaFaFkXomVdiJZ1IVrWhWhZF6JlXYiWdSFa1oVoWReiZV2IlnUhWtaFaFkXomVdiJZ1IVrWhWhZF6JlXYiWdSFa1oVoWReiZV2IlnUhWtaFaFkXomVdiJZ1IVrWhWhZF6JlXYiWdSFa1oVoWReiZV2IlnUhWtaFaFkXomVdiJZ1IVrWhWhZF6JlXYiWdSFa1oVoWReiZV2IlnUhWtaFaFkXomVdiJZ1IVrWhWhZF6JlXYiWdSFa1oVoWReiZV2IlnUhWtaFaFkXomVdiJZ1IVrWhWhZF6JlXYiWdSFa1oVoXReidV2I1nUhWteFaF3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+n4w1vMzxOUHczc/P2SWD/lY6/v8EFk75PwX/e0Pbb31/fJbrR/i64d8+a1WD/nyW60e8uW3Wj3ky2+1esiX32r1kC+/1eohX36r1UO+/Farh3z5rVYP+fJbrR7y5bdaPeTLb7V6yJffavWQ9U9//TW3r7/m9vXX3L7+mtvXX3P7+mtuX3/N7euvuX39Nbevv+b29dfcvv6a29dfc/u61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWV+taX61rfbWu9dW61lfrWl+ta321rvXVutZX61pfrWt9ta711brWV+taX61rfbWu9dW61lfrWl+ta321rvXVutZX61pfrWt9ta711brWV+taX61rfaWLEzN/O6TWD+n1Q5ZDC8sWQwvPf7Hf/tA+vgGeb7+/HXn+o70dmv7bavbxLfDqoH7koHngoI9vhFcHySMH6SMH2SMH+SMHxSMHPfKNkEe+EfLIN0Ie+UboI98IfeQboY98I/SRb8THN8no6m8HzXG8OygeOSgfOageOagvD5L464M+fp0Qo/N2ULy7eh9L/ecbs28Hne+o3h9UjxzUjxw0Dxz0sYB9itTfHoKnktzvDqpHDupHDpoHDvpYyD717fp2UJzPs78+SB45SB85yB45yC8PMn930MeXPOL7QfVuP32sHV8clMcjB8kjB+kjB/3g6s3b1yiPd/eInAcO+ljiPH//2l8OOn/Xvj/owzvsKWMfbyu5vDsoHzmoHjjoY3nwFE3fLkTlu+/ex9LdKZ3E24U43t2NPhbvrg6KBy75xwLe1UH1yEH9yEHzwEEfC3lXB8kjBz3yLf9Yzrs6yB856JFvxDzyjZgHvhE/iM07tf63W1jNvDtIHjlIHznIHjnIHzkoHjkoHzmoHjmorw7qd3ejHwTpXRwkxyMHySMHffyNaIu3g+J4d9DHV6/L3g7qfHdQP3LQPHDQx7/Urg76+Op1zveD6t1B+shB9shB/shB8chB+chB9cBBHwtO55uht+/e6LvP6WO87Hctwfme5D/cYf/47o/Fz//3l78+/+n999v8CWvoWwd6/nO9P/mPv9mnxvjj1uYHQWuf90M/iFq7OkgfOcgeOcgfOShWDzr/xX/7048pDTm8vgkl5z/PX38lPgY1Lo/qh46aR476mNi4PEoeOkofOsoeOsofOurD74fE2Lftdf5z/vUvm49/Ql0eVQ8d1Q8dNT84qo7vR/VfH/XxD7bLoz6+8nn0t+eopBx/fYP++NfX+Zfa34/yv+6BP/75dXlUPXRUP3TU/OCoju9HzV/f5j/+CXZ5lDx0lD50lD10lD90VDx01I++GzNvR6n89R1g6qGj+qGjfvTd+L6/zqPkomNQ6bdF9FRprxqM763C+c/vVE85DsaihLEoZSzKGItyxqKCsahkLKp+SlE1vytq3hXVTypKvhcl9ff9AhSRn1HU5z8ZRZSxKGMsyhmLCsaikrAo/dHui9/1ifn+MH3sMHvsMH/ssHjssHzssHrssH7ssHnoMDseO+yxb4k99i2xH3xL1PL7Rol8d5g/dlg8dlg+dlg9dtgPPm7z7/cOewcdiR+PHfaDK2n5vUirdz2P/+DcQr7/oot37+TE+7HD5qHD4njsMHnsMH3sMHvsMH/ssHjssB/sgMj6fli9a0LjR9+S3325YvTz51rOIW8vCH73EJT+4I9b3f/yx62pv//j/11QsxU0ZAXlwVaQsBWkbAUZW0HOVtAPdlnKd839FKf/+vb1gxcymaHfD3t/1/vBu5U8n6PfD3N9d1g8dtgPbs2Zvy/y3QP8B69Xso7v/VqpvDusHztsHjrsB29YLg+Txw7Txw6zxw77wbek/HeHxbvv5I9eBF0dlo8dVo8d9qNvif3+sHddxo9eBl0c9qO3QVeHyWOH6WOH2WOH+WOH/ehb8l00PO8J724KP3ondHVYPXZYP3bYj74l+fvD/vqurD96cXN1mDx2mD52mD12mD92WDx22A++Jf27p2mrvjusHjusHztsHjpMfvAt6eP3h9m7w+Sxw/Sxw+yxw/yxw+Kxw/Kxw37wLTn/9vth/9GD8YEUaqVvTZOV5btV+jmr+HxfJf9OPk5/pM/uLepz0Vh/pJCuFpX9vagPVqnnn/oHqzRklUGs8iN198mrPOkrOW8apPV/ZJse2Cc/En/3FnWxT+w5n3of3z+Plr/ufdSP55/6B6sIZBWFrGKQVZ7zlWyT76v43/m2Xb1+RlEX+ySe86l3/O7ziHctatjzT/2DVRyySkBWScgq9Yiipj+S7a8Om4cO+5EEfnWYPHaYPnaYPXaYP3ZYPHZYPnbYY9+SfOxbko99S34kDn/+4lR/gOunfae/0g95d5g/dlg8dlg+dlg9dlg/dtg8dNiPNOWrw+Sxw/Sxwx77lvRj35J+4Fty/kv89seynqAm6wlqsp6gJusJarKeoCbrCWqynqAm6wlqsp6gJusJarKeoCbrCWqynqAm6wlqsp6gJusJarKeoCbrCWqyPi1B1qclyPq0BFmfliDr0xJkfVqCrE9LkPVpCbI+LUHWpyXI+rQEWZ+WIOvTEmR9WoKsT0uQ9WkJsj4tQdanJcj6tARZn5Yg69MSZH1agqxPS5D1aQmyPi1B1qclyPq0BFmfliDr0xJkfVqCrE9LkPVpCbI+LUHWpyXI+rQEWZ+WIOvTEmR9WoKsT0uQ9WkJsj4tQdanJcj6tARZn5Yg69MSZH1agqxPS5D1aQmyPi1B1qclyPq0BFmfliDr0xJkfVqCrE9LkPVpCbI+LUHWpyXI+rQEWZ+WIOvTEmR9WoKsT0uQ9WkJsj4tQdanJcj6tARZn5Yg69MSZH1agqxPS5D1aQmyPi1B1qcl6Pq0BF2flqDr0xJ0fVrCD9iszw+J9UNy/ZBaP6TXD1n/9Ne1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r+wGP89kkrh+wOJ8fYuuH+PohsXbI/zr/7f/9h3/90z/8lz//07+dR/z2P/6Pf/7Hf//Tv/zzX/713/+///7tf/kv//qnP//5T//tP//3f/2Xf/yn//o//vWf/vOf/+Uff/vf/nD89n9+O0GT+KNp/N+/oTnnv7r0H13tN8RHvv3JyB/lkG9/cV6XP2r3b3+h3/8jfv5H/NuflOkfy+ptnNn//g+n/dH7tz/57QA9/5v2/b/pfq4a9tu//vbRetT5r/MWMPzbn9iR5xL1l+Pj+GMe3yvqP+q8Ha3j57/mG6X0v08hzlOI7wfU+Rd6Xsvzev7/","file_map":{"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"61":{"source":"// Simple Token Contract implementation in Noir\n\nfn main(\n    // The version of the HyleOutput. This is unchecked for now.\n    version: pub u32,\n    // The initial state of the contract. This is the state before the transaction is executed.\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    // The state of the contract after the transaction is executed.\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    // The identity used to execute the transaction. This is the same as the one used in the\n    // BlobTransaction.\n    identity_len: pub u8,\n    identity: pub str<256>,\n    // TxHash of the BlobTransaction.\n    tx_hash: pub str<64>,\n    // ------ Blobs ------\n    // The index of the blob being executed.\n    index: pub u32,\n    // Number of blobs used by the contract\n    // If blob_number is > 1, then you need multiple occurence of parameters group \"Blob\"\n    blob_number: pub u32,\n    // --- Blob\n    // At least one blob_index must match the index parameter\n    blob_index: pub u32,\n    blob_contract_name_len: pub u8,\n    blob_contract_name: pub str<256>,\n    blob_capacity: pub u32,\n    blob_len: pub u32,\n    blob: pub [u8; 32],\n    // ---\n    // Number of blobs in the transaction. tx_blob_count >= blob_number\n    tx_blob_count: pub u32,\n    // -------------------\n    // Weither the execution was successful or not. If false, the BlobTransaction will be\n    // settled as failed.\n    success: pub bool,\n    // ------ Private inputs ------\n    password: [u8; 32],\n) {\n    let mut id: BoundedVec<u8, 256> = BoundedVec::from_parts(identity.as_bytes(), identity_len as u32);\n    id.extend_from_slice(\":\".as_bytes());\n    id.extend_from_slice(password);\n\n    println(f\"Identity: {identity}\");\n    println(f\"Password: {password}\");\n    println(f\"extended id: {id}\");\n\n    // Hash the combined input using SHA-256\n    let input_hash = sha256::sha256_var(id.storage(), identity_len as u64 + 1 + 32);\n    println(f\"Input Hash: {input_hash}\");\n\n    assert(input_hash == blob);\n\n    assert(success == true);\n    assert(version == 1);\n    assert(initial_state_len == 4);\n    assert(next_state_len == 4);\n    assert(initial_state == [0; 4]);\n    assert(next_state == [0; 4]);\n    assert(blob_capacity == 32);\n    assert(blob_len == 32);\n    assert(blob_number == 1);\n    assert(tx_blob_count >= 1);\n}","path":"/home/laurip/src/mini/zkhackproj/noir/src/main.nr"},"64":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n","path":"/home/laurip/nargo/github.com/noir-lang/sha256/v0.1.0/src/sha256.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","build_msg_block","attach_len_to_msg_block","print_unconstrained","directive_integer_quotient","directive_invert","directive_to_radix"]}
\ No newline at end of file
+{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":4865417527115536477,"abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":256},"visibility":"public"},{"name":"tx_hash","type":{"kind":"string","length":64},"visibility":"public"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"blob_contract_name","type":{"kind":"string","length":256},"visibility":"public"},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"success","type":{"kind":"boolean"},"visibility":"public"},{"name":"password","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"1837938722211649573":{"error_kind":"string","string":"extend_from_slice out of bounds"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7d3Njl3XcYbhe+GYg7Pqf/lWgsCQZdkgQEiGJAcIDN97Dh2TCsImibL5vSNOjDDidqnP7sJa/vrpqr+9+uMPf/jrn3//5sc//fTLq9/9x99evf3p++9+ffPTj88//e1VRf3j//nLX7778d2ff/n1u59/ffW7k3Ffv/rhxz8+/886/vfXr/705u0Pr35X5++vX/jL58z7v53Hz29//e//+fpZovUlRl/iykvk4yuU8PIPJbw/KnH0JUxfwvUl4muUuPGhRDzs/5dIfYnSl2h9idGXuPIS9dCXOPoSpi/h+hL67i59d5e+u0vf3aXv7tJ3d+u7u/Xd3frubn13t767W9/dre/u1nd367u79d09+u4efXePvrtH392j7+7Rd/fou3v03T367h59d199d199d199d199d199d199d199d199d199d195d/fjoS9x9CVMX8L1JUJfIvUlSl+i9SVGX0Lf3Uff3Uff3Uff3Uff3Uff3Uff3Uff3Uff3Uff3Uff3abvbtN3t+m72/TdbfruNn13m767Td/dpu9u03e367vb9d3t+u52fXe7vrtd392u727Xd7fru9v13R367g59d4e+u0Pf3aHv7tB3d+i7O/TdHfruDn13p767U9/dqe/u1He33qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qqN3qqN3qqN3qqN3qrNI/QlUl+i9CVaX2L0JfTdrbdqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dq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V/usr/ZZX+2zvtpnfbXP+mqf9dU+66t91lf7rK/2WV/ts77aZ321z/pqn/XVPuurfdZX+6yv9llf7bO+2md9tc/6ap/11T7rq33WV/usr/ZZX+2zvtpnfbXP+mqf9dU+66t91lf7rK/2WV/ts77aZ321z/pqn/XVPuurfdZX+6yv9llf7bO+2md9tc/6ap/11T7rq33WV/usr/ZZX+2zvtpnfbXP+mqf9dU+66t91lf7rK/2WV/ts77aZ321z/pqn/XVPuurfdZX+6yv9llf7bO+2md9tc/6ap/11T7rq33WV/usr/ZZX+2zvtpnfbXP+mqf9dU+66t91lf7rK/2WV/ts77aZ321z/pqn/XVPuurfdZX+6yv9llf7bO+3md9vc/6ep/19T7r633W1/usr/dZX++zvt5nfb3P+nqf9fU+6+t91tf7rK/3WV/vs77eZ329z/p6n/X1PuvrfdbX+6yv91lf77O+3md9vc/62pYbM9890vtHZv/Iemhh+3Jo4d+ff/qv735+890f3v7wy/OJd//wrz9+/+ubn3785x9//e+/vP8nf/j5zdu3b/78+7/8/NP3P/zxrz//8Pu3P33/7p+9erz7j3fv10++dsv/fLdQ8/nHOPM6zD8sGX33V+55fR7n/d+w8dc289soxH/8l8TzvyTe/5V2e93ez3/X57/v/wA=","file_map":{"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"61":{"source":"// Simple Token Contract implementation in Noir\n\nfn main(\n    // The version of the HyleOutput. This is unchecked for now.\n    version: pub u32,\n    // The initial state of the contract. This is the state before the transaction is executed.\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    // The state of the contract after the transaction is executed.\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    // The identity used to execute the transaction. This is the same as the one used in the\n    // BlobTransaction.\n    identity_len: pub u8,\n    identity: pub str<256>,\n    // TxHash of the BlobTransaction.\n    tx_hash: pub str<64>,\n    // ------ Blobs ------\n    // The index of the blob being executed.\n    index: pub u32,\n    // Number of blobs used by the contract\n    // If blob_number is > 1, then you need multiple occurence of parameters group \"Blob\"\n    blob_number: pub u32,\n    // --- Blob\n    // At least one blob_index must match the index parameter\n    blob_index: pub u32,\n    blob_contract_name_len: pub u8,\n    blob_contract_name: pub str<256>,\n    blob_capacity: pub u32,\n    blob_len: pub u32,\n    blob: pub [u8; 32],\n    // ---\n    // Number of blobs in the transaction. tx_blob_count >= blob_number\n    tx_blob_count: pub u32,\n    // -------------------\n    // Weither the execution was successful or not. If false, the BlobTransaction will be\n    // settled as failed.\n    success: pub bool,\n    // ------ Private inputs ------\n    password: [u8; 32],\n) {\n    let mut id: BoundedVec<u8, 256> = BoundedVec::from_parts(identity.as_bytes(), identity_len as u32);\n    id.extend_from_slice(\":\".as_bytes());\n    id.extend_from_slice(password);\n\n    println(f\"Identity: {identity}\");\n    println(f\"Password: {password}\");\n    println(f\"extended id: {id}\");\n\n\n    assert(success == true);\n    assert(version == 1);\n    assert(initial_state_len == 4);\n    assert(next_state_len == 4);\n    assert(initial_state == [0; 4]);\n    assert(next_state == [0; 4]);\n    assert(blob_capacity == 32);\n    assert(blob_len == 32);\n    assert(blob_number == 1);\n    assert(tx_blob_count >= 1);\n}","path":"/home/maximilien/zkhack/noir/src/main.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","directive_integer_quotient","directive_invert"]}
\ No newline at end of file
diff --git a/noir/target/exemple-witness.gz b/noir/target/exemple-witness.gz
new file mode 100644
index 0000000000000000000000000000000000000000..05c58dbba8950978d4480453390eb0263b9419fe
GIT binary patch
literal 9698
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
JKRz29^&d50!6pCz

literal 0
HcmV?d00001

diff --git a/noir/target/proof b/noir/target/proof
index c1da9b438e16c0dd78d9de3464f081e6d03e5974..d6fd6a1c4ecc3e41765d4c3f27ef027eecc2e6fd 100644
GIT binary patch
literal 34180
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

literal 34180
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
U68bt~x6)3zVq~mmray-M3+>0J7XSbN

diff --git a/noir/target/vk b/noir/target/vk
index 7cace89d887a4110683d565181c0dfca14706717..ce23245478301fb098ba39b0992203929730d3d2 100644
GIT binary patch
delta 1467
zcmV;s1w{Ix4xtWz00000002M$000000000E000000007X00000000010000000000
z03&eK5C8yw{GKxsC;$L?xt=$L5C8yqxt<0WBme+;xj07QZU6uP03&eKZ~y>*{3CGH
zPyhgb{01rKjBU79<jfZ8f6g;RFTDPW%_NJms2Y9of&@%|U%L;R6V=C_tE<4^oBo%N
zd{d0rYQ}o)pMQs%X16r|ML7g^LJ&!Ieq+(K2&#|`z01cQ+{1wG@eMktqF~+M2(B0P
zb#wppB0?MVByXwM;kJTeDuRrj7q=K(2y+i`p4lSyU(4@k9Se$5k2DAi?@ka!Rdb~%
zS_!4yT+wQO(9?VY;1iEs1XNKyEGPP;C0U~~;d%C{VM?}};?TQ3Q$IBxZkYREJnv`I
zlmc$IXW<0LnxSgQo{4HS_qXOy_zycPj@wOV%l9!ay9i{hsIp{a@j!-$;3+Q>5D!Jr
zno=VOU$yuZ8CFRUaX_!5%OQU1YYi(evcBdt&RQ{Kd7jHu6OX0(jd`4k6%=5#<{J;R
zjxmtXs$3UqTg~|IAoLtL8gwuf-_xwRV+Mw5Hlg@>s-eYS22A222EX;#qA4O%FK}Bm
z=^6I^=6F1cK7Mwuc31mqo2M`DeS!I8?vG&5li>kCe-o(k{R645v+E@a;+{kWv`zMq
zFOKMC(j+!Y)P+`1QVSAdsl}`c@=R@2YP2F$zEXt%;lM|F=C-HCDFgL|eFJI`Mh=0K
z2trIQ?_dwEfW<S@nQkO+97s9x@_e<TSR+=)SXVJ-AwMfratSF0oNw#D6=H;#<^=@%
z9m@Spe`*zdF3kNC^=w65evkRXAJ*SF9o50v>D84FPmDVB?fnZ1d>~(pxAxx+Z!Izc
zG|4Co{q2uMWqn{$9MM-1>Ix@Spc7*JAyL8@_Ce;(X_K0tzWsW%Ez6m3e0Mrxi{2=S
zSi?vZ-nrUFGl%{lNaWrZbI((;fC2mfvE1qdf9q@tFW69tk@LbuW?=wP!BFHEOnaBx
zO&W>EgR5WI;z0!~i_@&&roL?!ZA(tB8QOV00`2+?q(azqHpKC-H(($Xr>dt0(9AA8
zo#+vDFg@kYAC0~arGv&G!L}k(VBh=$gLZ=o-p1urP{^J`*;T0Vk*wXW-#`TVtFtYa
zf3j(v6KZB6y+Uulrd=U1u}!CSH3mOO7r*emKKJeyBX}sH7TR_Il<^SL<z%$4Gc;bN
zp7r{vJ@;#D(CIL&@{{Li0=sv3E>l-vPFx83m8j$kEmIoJ{HO=rwU)kndK=0K4aanz
zT8WsWw7IiAM@|svRBsS0YpM`+beY$qe;#^L&lvTy<aLtTHitI@p*`?xKl5X{@b6bT
zSrN@ysU7%L0RWE&f!y~q2W7NQ2PuiX-T|xo#NbI9Td`|;9b5#nRwh8*vlNc;)xGyI
zy%ZlNAHwm&;(F8+iL8HKe`u738x_gYvjj>h66=*%`7p;8gsIcPGwb6=WN_cgf965N
zRIUgP9$}fIKV?@edQ8t?8}%M`jEO0NLfjtS97FS4{1O)D<y6JSe3c@HX2$ZBQF)EM
zfvaU(@>#dg*yO7*778k_4Hxcx%;JKZ7bJJuT1ti(JvnyJ>W6{x>0J`ydx9L!nzZx0
z!>J~jUZ9Gw*o_=zddb>aM7X2gf491UULJK43o*ERvtjW7TGe+Z9XzH23gY~&S_{BI
zDmN~i@FW5Y9~APsqQO~qk*3q2z@DR0;2w|~!SkxN>P)M3kHpm!pWyJGQP7N~;5^;5
zYcHaagVh8fpaFNZNz+_9=Tu(?`nVrNVb6D=5J)|d^GW**Ig1`w?`NcY2N?u3kP?(e
zv!Mk*0YDKc_HDh^S8W)U6pdL?|APbNsI4!7*H$*t-s$yb&$I{lJR}9gi*{&7KR(bX
Vad;K%x>^l14uWaKx5C>@?DRz}uVDZH

delta 1467
zcmV;s1w{Ix4xtWz00000001BW000000000D000000007X000000000100u#PZ~y>!
z8aPJbZU6uP00u@EBme+-8U{d3JOBUy00000000000LCR$kN^OG{042(C;$L>8U}zh
z5C8yp8Z5zewV6;nQ_QMLY8iX-`#y+*cyc;S-iN;Rga%Q6a~Kr>>vnO9Q&--2-#C#?
z&AX3_-I()51*4BSWlCE)L?s!}$txj08!v+4{|j2#vZguzz>cW;uIl;~&0j3rCsqW5
zLa)}nHrnC8_K<F4>zm;mNqpOVSeJ4JEK2ZGxFs0(imnGvt?>pu0l6;h@M#5oK2g2r
z1H6-ta$`z=*Hg^`(hh%3E)=Pl6~p(BOp#&l0^yBLfh;bNg=bMvzcr*1OS|!4%_d-r
zQ_Wx%?}5hk3`*GNN`pp+#$;n`?P1Ce;c1}qc49cws+=#w!X<h+FAt(<AGLLJ%%X%@
zq(5;Ig!6Z{=BD3UD)IZDPzJkAiq!Q7s}c~4qpx#hK%oVN6$b^njYX~Xa3@bX{1n>h
zVY*!HhT*4gMvRqsN0dS>4HAnCHDbca!e9@_c=R(;IY-ULYw|Nd$;XsC^|-BJAK+|S
z7lKK*x{>v)Y}oRkgK+d=G>s}7aO7H-5L@pGli>kCe=G~4MPa7US08Q2)6$hKzEqo!
zDel&h9%0u>#J5iLxGA*2g1*_B20ENlHn}?1fAjkkmA{`GeE7eQNu&GarVQk=&C|8}
zGT>up$Tjf%@*s1^q)Eo8n?}hau(2_ob}esFtA~&Fy``h|%mH2YAwckN%RL7o3oPrk
z>HR<Xe_|kl&P=e7#dGzpCT_zB*tuyiMf<5(dd2lwowhMHEBO^N<;{*|LUx5Xg1W|c
z-}6}_`D1d%Ek6-9{1IhJc*Ppj$c4o*r~LQl2Dg};6iZCjNBnTOBtPp5TP+dKY1Ro`
z(#Coim9HGpu?0$Z)#&c}*utZ6N>tH?0Qj%AfA!=LusAMGBeh(Id`kHqkVFZiVD@;*
zh4(MjI?OlD0QJKTYx0en217aOBBPb$7s$C*TVBF`?VWQ~mZsOzKPAN(#*D8@;j@me
zX%s7DYrcb5*;!39Y3`{zTtNr&W&Lv<IO)7zYg1K@wfcR5@-AeS8bvYO|D?iV`44)m
ze{wt39?&G}10ajB?l(%d9W1fB{wA{4d8EHn%CS#FNu!#*CT4>vB$mibmLLzR3X(Uo
z+wbAA8mo?{48`h^X$F@!A&RMZJw}jIHl|<r-xOMy20rMppJp>x_CE}}eQmC03Ef_1
z9|bLZHZOi(N5tc1kwMfT;{}19uCeofe`h#P7%7$SPp0XHILD6j#;Y!0w`6D)du@8J
z7`3#t8w_ZH1q?gL>Pb@taQi4L$iH1<m<;lfyo8|dz?v6ypo*&Jye5B_+?l<1)Z0md
z`uO_Z4_<!n{xdb{h+#yv$_oyVX%@NA@O-^n6&v!lm+h7J43Ixedco#F8-zipf0q)V
zGwueAr0mYO#(_C>0jHSy7}#^|;1Z!{*D<WGNf~$MBwY#u5&x)?<A>aASKPBcRe>Ge
z`;a0l=qN}5zg1_qGo=D@FU}i}OYl$sZtY;i>1(8(dzEBa6?Zj^&4$`|+`uTzc($I8
zW85jAI&p<j9q?02whZD2tQ%Nrf4)tQ<kEN*5m-v=QL2#ou8JyqN_V%EAa#Nm!v#=B
z^pB;76HeI;r^+T}+?P>6Yw+)~&2&Z--2uAzWS0KzZ!VXOGIAOe=i8JJj72s9-m3Se
zY>cjRN`$52ri0E-sNU703X_2tX|gI94X0VQuxb~a!S8rmZpDSCO<GYw2b=NL@pr#w
zv!Mk*0YDZWIY{`aufV~RGQl=f&2kfqy#6h4&f6W(0p7A4uJRw~l16gRT$`NF_$Fnp
VYy&zJUDSqIfLTuQAfue@CD!bpzfS-F

diff --git a/zkhack-portal/bun.lockb b/zkhack-portal/bun.lockb
new file mode 100755
index 0000000000000000000000000000000000000000..521e7a92a354d01e0d07e94fb23ba82c01816d23
GIT binary patch
literal 162414
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

literal 0
HcmV?d00001

diff --git a/zkhack-portal/public/circuit.json b/zkhack-portal/public/circuit.json
index 2c8c25f..56a7a90 100644
--- a/zkhack-portal/public/circuit.json
+++ b/zkhack-portal/public/circuit.json
@@ -1 +1 @@
-{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":13006106641385494867,"abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":256},"visibility":"public"},{"name":"tx_hash","type":{"kind":"string","length":64},"visibility":"public"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"blob_contract_name","type":{"kind":"string","length":256},"visibility":"public"},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"success","type":{"kind":"boolean"},"visibility":"public"},{"name":"password","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"1837938722211649573":{"error_kind":"string","string":"extend_from_slice out of bounds"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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dV2I1nUhWteFaF3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+nRd69N1rU/XtT5d1/p0XevTda1P17U+Xdf6dF3r03WtT9e1Pl3X+n4w1vMzxOUHczc/P2SWD/lY6/v8EFk75PwX/e0Pbb31/fJbrR/i64d8+a1WD/nyW60e8uW3Wj3ky2+1esiX32r1kC+/1eohX36r1UO+/Farh3z5rVYP+fJbrR7y5bdaPeTLb7V6yJffavWQ9U9//TW3r7/m9vXX3L7+mtvXX3P7+mtuX3/N7euvuX39Nbevv+b29dfcvv6a29dfc/u61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61ufrWp+va32+rvX5utbn61qfr2t9vq71+brW5+tan69rfb6u9fm61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutYX61pfrGt9sa71xbrWF+taX6xrfbGu9cW61hfrWl+sa32xrvXFutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWl+taX65rfbmu9eW61pfrWl+ua325rvXlutaX61pfrmt9ua715brWV+taX61rfbWu9dW61lfrWl+ta321rvXVutZX61pfrWt9ta711brWV+taX61rfbWu9dW61lfrWl+ta321rvXVutZX61pfrWt9ta711brWV+taX61rfaWLEzN/O6TWD+n1Q5ZDC8sWQwvPf7Hf/tA+vgGeb7+/HXn+o70dmv7bavbxLfDqoH7koHngoI9vhFcHySMH6SMH2SMH+SMHxSMHPfKNkEe+EfLIN0Ie+UboI98IfeQboY98I/SRb8THN8no6m8HzXG8OygeOSgfOageOagvD5L464M+fp0Qo/N2ULy7eh9L/ecbs28Hne+o3h9UjxzUjxw0Dxz0sYB9itTfHoKnktzvDqpHDupHDpoHDvpYyD717fp2UJzPs78+SB45SB85yB45yC8PMn930MeXPOL7QfVuP32sHV8clMcjB8kjB+kjB/3g6s3b1yiPd/eInAcO+ljiPH//2l8OOn/Xvj/owzvsKWMfbyu5vDsoHzmoHjjoY3nwFE3fLkTlu+/ex9LdKZ3E24U43t2NPhbvrg6KBy75xwLe1UH1yEH9yEHzwEEfC3lXB8kjBz3yLf9Yzrs6yB856JFvxDzyjZgHvhE/iM07tf63W1jNvDtIHjlIHznIHjnIHzkoHjkoHzmoHjmorw7qd3ejHwTpXRwkxyMHySMHffyNaIu3g+J4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","file_map":{"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"61":{"source":"// Simple Token Contract implementation in Noir\n\nfn main(\n    // The version of the HyleOutput. This is unchecked for now.\n    version: pub u32,\n    // The initial state of the contract. This is the state before the transaction is executed.\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    // The state of the contract after the transaction is executed.\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    // The identity used to execute the transaction. This is the same as the one used in the\n    // BlobTransaction.\n    identity_len: pub u8,\n    identity: pub str<256>,\n    // TxHash of the BlobTransaction.\n    tx_hash: pub str<64>,\n    // ------ Blobs ------\n    // The index of the blob being executed.\n    index: pub u32,\n    // Number of blobs used by the contract\n    // If blob_number is > 1, then you need multiple occurence of parameters group \"Blob\"\n    blob_number: pub u32,\n    // --- Blob\n    // At least one blob_index must match the index parameter\n    blob_index: pub u32,\n    blob_contract_name_len: pub u8,\n    blob_contract_name: pub str<256>,\n    blob_capacity: pub u32,\n    blob_len: pub u32,\n    blob: pub [u8; 32],\n    // ---\n    // Number of blobs in the transaction. tx_blob_count >= blob_number\n    tx_blob_count: pub u32,\n    // -------------------\n    // Weither the execution was successful or not. If false, the BlobTransaction will be\n    // settled as failed.\n    success: pub bool,\n    // ------ Private inputs ------\n    password: [u8; 32],\n) {\n    let mut id: BoundedVec<u8, 256> = BoundedVec::from_parts(identity.as_bytes(), identity_len as u32);\n    id.extend_from_slice(\":\".as_bytes());\n    id.extend_from_slice(password);\n\n    println(f\"Identity: {identity}\");\n    println(f\"Password: {password}\");\n    println(f\"extended id: {id}\");\n\n    // Hash the combined input using SHA-256\n    let input_hash = sha256::sha256_var(id.storage(), identity_len as u64 + 1 + 32);\n    println(f\"Input Hash: {input_hash}\");\n\n    assert(input_hash == blob);\n\n    assert(success == true);\n    assert(version == 1);\n    assert(initial_state_len == 4);\n    assert(next_state_len == 4);\n    assert(initial_state == [0; 4]);\n    assert(next_state == [0; 4]);\n    assert(blob_capacity == 32);\n    assert(blob_len == 32);\n    assert(blob_number == 1);\n    assert(tx_blob_count >= 1);\n}","path":"/home/laurip/src/mini/zkhackproj/noir/src/main.nr"},"64":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n","path":"/home/laurip/nargo/github.com/noir-lang/sha256/v0.1.0/src/sha256.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","build_msg_block","attach_len_to_msg_block","print_unconstrained","directive_integer_quotient","directive_invert","directive_to_radix"]}
\ No newline at end of file
+{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":4865417527115536477,"abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":256},"visibility":"public"},{"name":"tx_hash","type":{"kind":"string","length":64},"visibility":"public"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"blob_contract_name","type":{"kind":"string","length":256},"visibility":"public"},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"success","type":{"kind":"boolean"},"visibility":"public"},{"name":"password","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"1837938722211649573":{"error_kind":"string","string":"extend_from_slice out of bounds"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7d3Njl3XcYbhe+GYg7Pqf/lWgsCQZdkgQEiGJAcIDN97Dh2TCsImibL5vSNOjDDidqnP7sJa/vrpqr+9+uMPf/jrn3//5sc//fTLq9/9x99evf3p++9+ffPTj88//e1VRf3j//nLX7778d2ff/n1u59/ffW7k3Ffv/rhxz8+/886/vfXr/705u0Pr35X5++vX/jL58z7v53Hz29//e//+fpZovUlRl/iykvk4yuU8PIPJbw/KnH0JUxfwvUl4muUuPGhRDzs/5dIfYnSl2h9idGXuPIS9dCXOPoSpi/h+hL67i59d5e+u0vf3aXv7tJ3d+u7u/Xd3frubn13t767W9/dre/u1nd367u79d09+u4efXePvrtH392j7+7Rd/fou3v03T367h59d199d199d199d199d199d199d199d199d199d195d/fjoS9x9CVMX8L1JUJfIvUlSl+i9SVGX0Lf3Uff3Uff3Uff3Uff3Uff3Uff3Uff3Uff3Uff3Uff3abvbtN3t+m72/TdbfruNn13m767Td/dpu9u03e367vb9d3t+u52fXe7vrtd392u727Xd7fru9v13R367g59d4e+u0Pf3aHv7tB3d+i7O/TdHfruDn13p767U9/dqe/u1He33qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qqN3qqN3qqN3qqN3qrNI/QlUl+i9CVaX2L0JfTdrbdqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dq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V/usr/ZZX+2zvtpnfbXP+mqf9dU+66t91lf7rK/2WV/ts77aZ321z/pqn/XVPuurfdZX+6yv9llf7bO+2md9tc/6ap/11T7rq33WV/usr/ZZX+2zvtpnfbXP+mqf9dU+66t91lf7rK/2WV/ts77aZ321z/pqn/XVPuurfdZX+6yv9llf7bO+2md9tc/6ap/11T7rq33WV/usr/ZZX+2zvtpnfbXP+mqf9dU+66t91lf7rK/2WV/ts77aZ321z/pqn/XVPuurfdZX+6yv9llf7bO+2md9tc/6ap/11T7rq33WV/usr/ZZX+2zvtpnfbXP+mqf9dU+66t91lf7rK/2WV/ts77aZ321z/pqn/XVPuurfdZX+6yv9llf7bO+3md9vc/6ep/19T7r633W1/usr/dZX++zvt5nfb3P+nqf9fU+6+t91tf7rK/3WV/vs77eZ329z/p6n/X1PuvrfdbX+6yv91lf77O+3md9vc/62pYbM9890vtHZv/Iemhh+3Jo4d+ff/qv735+890f3v7wy/OJd//wrz9+/+ubn3785x9//e+/vP8nf/j5zdu3b/78+7/8/NP3P/zxrz//8Pu3P33/7p+9erz7j3fv10++dsv/fLdQ8/nHOPM6zD8sGX33V+55fR7n/d+w8dc289soxH/8l8TzvyTe/5V2e93ez3/X57/v/wA=","file_map":{"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"61":{"source":"// Simple Token Contract implementation in Noir\n\nfn main(\n    // The version of the HyleOutput. This is unchecked for now.\n    version: pub u32,\n    // The initial state of the contract. This is the state before the transaction is executed.\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    // The state of the contract after the transaction is executed.\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    // The identity used to execute the transaction. This is the same as the one used in the\n    // BlobTransaction.\n    identity_len: pub u8,\n    identity: pub str<256>,\n    // TxHash of the BlobTransaction.\n    tx_hash: pub str<64>,\n    // ------ Blobs ------\n    // The index of the blob being executed.\n    index: pub u32,\n    // Number of blobs used by the contract\n    // If blob_number is > 1, then you need multiple occurence of parameters group \"Blob\"\n    blob_number: pub u32,\n    // --- Blob\n    // At least one blob_index must match the index parameter\n    blob_index: pub u32,\n    blob_contract_name_len: pub u8,\n    blob_contract_name: pub str<256>,\n    blob_capacity: pub u32,\n    blob_len: pub u32,\n    blob: pub [u8; 32],\n    // ---\n    // Number of blobs in the transaction. tx_blob_count >= blob_number\n    tx_blob_count: pub u32,\n    // -------------------\n    // Weither the execution was successful or not. If false, the BlobTransaction will be\n    // settled as failed.\n    success: pub bool,\n    // ------ Private inputs ------\n    password: [u8; 32],\n) {\n    let mut id: BoundedVec<u8, 256> = BoundedVec::from_parts(identity.as_bytes(), identity_len as u32);\n    id.extend_from_slice(\":\".as_bytes());\n    id.extend_from_slice(password);\n\n    println(f\"Identity: {identity}\");\n    println(f\"Password: {password}\");\n    println(f\"extended id: {id}\");\n\n\n    assert(success == true);\n    assert(version == 1);\n    assert(initial_state_len == 4);\n    assert(next_state_len == 4);\n    assert(initial_state == [0; 4]);\n    assert(next_state == [0; 4]);\n    assert(blob_capacity == 32);\n    assert(blob_len == 32);\n    assert(blob_number == 1);\n    assert(tx_blob_count >= 1);\n}","path":"/home/maximilien/zkhack/noir/src/main.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","directive_integer_quotient","directive_invert"]}
\ No newline at end of file
diff --git a/zkhack-portal/src/lib/hyli/hyli.ts b/zkhack-portal/src/lib/hyli/hyli.ts
index a5b03a5..c4ecd4c 100644
--- a/zkhack-portal/src/lib/hyli/hyli.ts
+++ b/zkhack-portal/src/lib/hyli/hyli.ts
@@ -101,15 +101,10 @@ const build_proof_transaction = async (
   //const { witness } = await noir.execute({ x, y });
 
   const hashed_password_bytes = await sha256(stringToBytes(PASSWORD));
-  let encoder = new TextEncoder();
-  let id_prefix = encoder.encode(`${IDENTITY}:`);
-  let extended_id = new Uint8Array([...id_prefix, ...hashed_password_bytes]);
-  const stored_hash = await sha256(extended_id);
 
   const data = generateProverData(
     IDENTITY,
     hashed_password_bytes,
-    stored_hash,
     tx_hash,
     blob_index,
     tx_blob_count
@@ -143,7 +138,6 @@ const build_proof_transaction = async (
 const generateProverData = (
   id: string,
   pwd: Uint8Array,
-  stored_hash: Uint8Array,
   tx: string,
   blob_index: number,
   tx_blob_count: number
@@ -163,7 +157,7 @@ const generateProverData = (
   const blob_contract_name = CONTRACT_NAME.padEnd(256, "0");
   const blob_capacity = 32;
   const blob_len = 32;
-  const blob: number[] = Array.from(stored_hash);
+  const blob: number[] = Array.from(pwd);
   const success = 1;
   const password: number[] = Array.from(pwd);
   assert(password.length == 32, "Password length is not 32 bytes");
-- 
2.49.0

