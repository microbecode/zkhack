{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":4865417527115536477,"abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":256},"visibility":"public"},{"name":"tx_hash","type":{"kind":"string","length":64},"visibility":"public"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"blob_contract_name","type":{"kind":"string","length":256},"visibility":"public"},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"success","type":{"kind":"boolean"},"visibility":"public"},{"name":"password","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"1837938722211649573":{"error_kind":"string","string":"extend_from_slice out of bounds"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7d3Njl3XcYbhe+GYg7Pqf/lWgsCQZdkgQEiGJAcIDN97Dh2TCsImibL5vSNOjDDidqnP7sJa/vrpqr+9+uMPf/jrn3//5sc//fTLq9/9x99evf3p++9+ffPTj88//e1VRf3j//nLX7778d2ff/n1u59/ffW7k3Ffv/rhxz8+/886/vfXr/705u0Pr35X5++vX/jL58z7v53Hz29//e//+fpZovUlRl/iykvk4yuU8PIPJbw/KnH0JUxfwvUl4muUuPGhRDzs/5dIfYnSl2h9idGXuPIS9dCXOPoSpi/h+hL67i59d5e+u0vf3aXv7tJ3d+u7u/Xd3frubn13t767W9/dre/u1nd367u79d09+u4efXePvrtH392j7+7Rd/fou3v03T367h59d199d199d199d199d199d199d199d199d199d195d/fjoS9x9CVMX8L1JUJfIvUlSl+i9SVGX0Lf3Uff3Uff3Uff3Uff3Uff3Uff3Uff3Uff3Uff3Uff3abvbtN3t+m72/TdbfruNn13m767Td/dpu9u03e367vb9d3t+u52fXe7vrtd392u727Xd7fru9v13R367g59d4e+u0Pf3aHv7tB3d+i7O/TdHfruDn13p767U9/dqe/u1He33qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qq13qqN3qqN3qqN3qqN3qrNI/QlUl+i9CVaX2L0JfTdrbdqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dqo7dq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V/usr/ZZX+2zvtpnfbXP+mqf9dU+66t91lf7rK/2WV/ts77aZ321z/pqn/XVPuurfdZX+6yv9llf7bO+2md9tc/6ap/11T7rq33WV/usr/ZZX+2zvtpnfbXP+mqf9dU+66t91lf7rK/2WV/ts77aZ321z/pqn/XVPuurfdZX+6yv9llf7bO+2md9tc/6ap/11T7rq33WV/usr/ZZX+2zvtpnfbXP+mqf9dU+66t91lf7rK/2WV/ts77aZ321z/pqn/XVPuurfdZX+6yv9llf7bO+2md9tc/6ap/11T7rq33WV/usr/ZZX+2zvtpnfbXP+mqf9dU+66t91lf7rK/2WV/ts77aZ321z/pqn/XVPuurfdZX+6yv9llf7bO+3md9vc/6ep/19T7r633W1/usr/dZX++zvt5nfb3P+nqf9fU+6+t91tf7rK/3WV/vs77eZ329z/p6n/X1PuvrfdbX+6yv91lf77O+3md9vc/62pYbM9890vtHZv/Iemhh+3Jo4d+ff/qv735+890f3v7wy/OJd//wrz9+/+ubn3785x9//e+/vP8nf/j5zdu3b/78+7/8/NP3P/zxrz//8Pu3P33/7p+9erz7j3fv10++dsv/fLdQ8/nHOPM6zD8sGX33V+55fR7n/d+w8dc289soxH/8l8TzvyTe/5V2e93ez3/X57/v/wA=","file_map":{"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"61":{"source":"// Simple Token Contract implementation in Noir\n\nfn main(\n    // The version of the HyleOutput. This is unchecked for now.\n    version: pub u32,\n    // The initial state of the contract. This is the state before the transaction is executed.\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    // The state of the contract after the transaction is executed.\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    // The identity used to execute the transaction. This is the same as the one used in the\n    // BlobTransaction.\n    identity_len: pub u8,\n    identity: pub str<256>,\n    // TxHash of the BlobTransaction.\n    tx_hash: pub str<64>,\n    // ------ Blobs ------\n    // The index of the blob being executed.\n    index: pub u32,\n    // Number of blobs used by the contract\n    // If blob_number is > 1, then you need multiple occurence of parameters group \"Blob\"\n    blob_number: pub u32,\n    // --- Blob\n    // At least one blob_index must match the index parameter\n    blob_index: pub u32,\n    blob_contract_name_len: pub u8,\n    blob_contract_name: pub str<256>,\n    blob_capacity: pub u32,\n    blob_len: pub u32,\n    blob: pub [u8; 32],\n    // ---\n    // Number of blobs in the transaction. tx_blob_count >= blob_number\n    tx_blob_count: pub u32,\n    // -------------------\n    // Weither the execution was successful or not. If false, the BlobTransaction will be\n    // settled as failed.\n    success: pub bool,\n    // ------ Private inputs ------\n    password: [u8; 32],\n) {\n    let mut id: BoundedVec<u8, 256> = BoundedVec::from_parts(identity.as_bytes(), identity_len as u32);\n    id.extend_from_slice(\":\".as_bytes());\n    id.extend_from_slice(password);\n\n    println(f\"Identity: {identity}\");\n    println(f\"Password: {password}\");\n    println(f\"extended id: {id}\");\n\n\n    assert(success == true);\n    assert(version == 1);\n    assert(initial_state_len == 4);\n    assert(next_state_len == 4);\n    assert(initial_state == [0; 4]);\n    assert(next_state == [0; 4]);\n    assert(blob_capacity == 32);\n    assert(blob_len == 32);\n    assert(blob_number == 1);\n    assert(tx_blob_count >= 1);\n}","path":"/home/maximilien/zkhack/noir/src/main.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","directive_integer_quotient","directive_invert"]}